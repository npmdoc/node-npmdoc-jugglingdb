<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/1602/jugglingdb"

    >jugglingdb (v1.0.2)</a>
</h1>
<h4>ORM for every database: redis, mysql, neo4j, mongodb, couchdb, postgres, sqlite</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb">module jugglingdb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass">
            function <span class="apidocSignatureSpan">jugglingdb.</span>AbstractClass
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL">
            function <span class="apidocSignatureSpan">jugglingdb.</span>BaseSQL
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema">
            function <span class="apidocSignatureSpan">jugglingdb.</span>Schema
            <span class="apidocSignatureSpan">(name, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.init">
            function <span class="apidocSignatureSpan">jugglingdb.</span>init
            <span class="apidocSignatureSpan">(compound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list">
            function <span class="apidocSignatureSpan">jugglingdb.</span>list
            <span class="apidocSignatureSpan">(data, type, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.loadSchema">
            function <span class="apidocSignatureSpan">jugglingdb.</span>loadSchema
            <span class="apidocSignatureSpan">(filename, settings, compound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.test">
            function <span class="apidocSignatureSpan">jugglingdb.</span>test
            <span class="apidocSignatureSpan">(exportCasesHere, schema)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>AbstractClass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>BaseSQL.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>Schema.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>Schema.types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>jutil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>list.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>scope</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.</span>validations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jugglingdb.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.AbstractClass">module jugglingdb.AbstractClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.AbstractClass">
            function <span class="apidocSignatureSpan">jugglingdb.</span>AbstractClass
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass._forDB">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>_forDB
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass._fromDB">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>_fromDB
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.all">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.belongsTo">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>belongsTo
            <span class="apidocSignatureSpan">(anotherClass, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.count">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.create">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.defineProperty">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.destroyAll">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>destroyAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.exists">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>exists
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.find">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.findOne">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>findOne
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.findOrCreate">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.hasAndBelongsToMany">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>hasAndBelongsToMany
            <span class="apidocSignatureSpan">(anotherClass, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.hasMany">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>hasMany
            <span class="apidocSignatureSpan">(anotherClass, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.include">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>include
            <span class="apidocSignatureSpan">(objects, include, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.iterate">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>iterate
            <span class="apidocSignatureSpan">(filter, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.relationNameFor">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>relationNameFor
            <span class="apidocSignatureSpan">(foreignKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.scope">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>scope
            <span class="apidocSignatureSpan">(name, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.toString">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.update">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.updateOrCreate">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>updateOrCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.upsert">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>upsert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validate">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validateAsync">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesExclusionOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesFormatOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesInclusionOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesLengthOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesPresenceOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.whatTypeName">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>whatTypeName
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>beforeValidate</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.AbstractClass.prototype">module jugglingdb.AbstractClass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype._adapter">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>_adapter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype._initProperties">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>_initProperties
            <span class="apidocSignatureSpan">(data, applySetters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.destroy">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.fromObject">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>fromObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.inspect">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.isNewRecord">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>isNewRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.isValid">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>isValid
            <span class="apidocSignatureSpan">(callback, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.propertyChanged">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>propertyChanged
            <span class="apidocSignatureSpan">(attr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.reload">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>reload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.reset">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.save">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.toJSON">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.toObject">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>toObject
            <span class="apidocSignatureSpan">(onlySchema, cachedRelations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.trigger">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>trigger
            <span class="apidocSignatureSpan">(actionName, work, data, quit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.updateAttribute">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>updateAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.updateAttributes">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>updateAttributes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.AbstractClass.prototype.whatTypeName">
            function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>whatTypeName
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.BaseSQL">module jugglingdb.BaseSQL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.BaseSQL">
            function <span class="apidocSignatureSpan">jugglingdb.</span>BaseSQL
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.BaseSQL.prototype">module jugglingdb.BaseSQL.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.automigrate">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>automigrate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.command">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>command
            <span class="apidocSignatureSpan">(sql, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.count">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>count
            <span class="apidocSignatureSpan">(model, callback, where)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.createTable">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>createTable
            <span class="apidocSignatureSpan">(model, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.define">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>define
            <span class="apidocSignatureSpan">(descr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.defineProperty">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>defineProperty
            <span class="apidocSignatureSpan">(model, prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.destroy">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>destroy
            <span class="apidocSignatureSpan">(model, id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.destroyAll">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>destroyAll
            <span class="apidocSignatureSpan">(model, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.disconnect">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.dropTable">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>dropTable
            <span class="apidocSignatureSpan">(model, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.escapeId">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>escapeId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.escapeName">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>escapeName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.exists">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>exists
            <span class="apidocSignatureSpan">(model, id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.find">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>find
            <span class="apidocSignatureSpan">(model, id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.query">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>query
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.queryOne">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>queryOne
            <span class="apidocSignatureSpan">(sql, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.save">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>save
            <span class="apidocSignatureSpan">(model, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.table">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>table
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.tableEscaped">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>tableEscaped
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.BaseSQL.prototype.updateAttributes">
            function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>updateAttributes
            <span class="apidocSignatureSpan">(model, id, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.Schema">module jugglingdb.Schema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.Schema">
            function <span class="apidocSignatureSpan">jugglingdb.</span>Schema
            <span class="apidocSignatureSpan">(name, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.JSON">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>JSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.Text">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>Text
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.registerType">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>registerType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.super_">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jugglingdb.Schema.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.Schema.prototype">module jugglingdb.Schema.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.automigrate">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>automigrate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.autoupdate">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>autoupdate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.copyModel">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>copyModel
            <span class="apidocSignatureSpan">(Master)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.define">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>define
            <span class="apidocSignatureSpan">(className, properties, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.defineForeignKey">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>defineForeignKey
            <span class="apidocSignatureSpan">(className, key, foreignClassName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.defineProperty">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>defineProperty
            <span class="apidocSignatureSpan">(model, prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.disconnect">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.extendModel">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>extendModel
            <span class="apidocSignatureSpan">(model, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.freeze">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>freeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.isActual">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>isActual
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.log">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>log
            <span class="apidocSignatureSpan">(sql, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.tableName">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>tableName
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.prototype.transaction">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>transaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.Schema.types">module jugglingdb.Schema.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.types.JSON">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.types.</span>JSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.Schema.types.Text">
            function <span class="apidocSignatureSpan">jugglingdb.Schema.types.</span>Text
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.jutil">module jugglingdb.jutil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.jutil.inherits">
            function <span class="apidocSignatureSpan">jugglingdb.jutil.</span>inherits
            <span class="apidocSignatureSpan">(newClass, baseClass)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.list">module jugglingdb.list</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.list">
            function <span class="apidocSignatureSpan">jugglingdb.</span>list
            <span class="apidocSignatureSpan">(data, type, parent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.list.prototype">module jugglingdb.list.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.autoincrement">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>autoincrement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.concat">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.every">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>every
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.filter">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>filter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.find">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>find
            <span class="apidocSignatureSpan">(pattern, field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.forEach">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>forEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.indexOf">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>indexOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.inspect">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.join">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.map">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>map
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.pop">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.push">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>push
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.remove">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>remove
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.removeAt">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>removeAt
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.reverse">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.shift">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.slice">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.some">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>some
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.sort">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.splice">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>splice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.toJSON">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.toObject">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.toSource">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.toString">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.list.prototype.unshift">
            function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>unshift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.schema">module jugglingdb.schema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.schema.Schema">
            function <span class="apidocSignatureSpan">jugglingdb.schema.</span>Schema
            <span class="apidocSignatureSpan">(name, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.scope">module jugglingdb.scope</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.scope.defineScope">
            function <span class="apidocSignatureSpan">jugglingdb.scope.</span>defineScope
            <span class="apidocSignatureSpan">(cls, targetClass, name, params, methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.utils">module jugglingdb.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.utils.safeRequire">
            function <span class="apidocSignatureSpan">jugglingdb.utils.</span>safeRequire
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jugglingdb.validations">module jugglingdb.validations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jugglingdb.validations.ValidationError">
            function <span class="apidocSignatureSpan">jugglingdb.validations.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb" id="apidoc.module.jugglingdb">module jugglingdb</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass" id="apidoc.element.jugglingdb.AbstractClass">
        function <span class="apidocSignatureSpan">jugglingdb.</span>AbstractClass
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">[Model undefined]</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL" id="apidoc.element.jugglingdb.BaseSQL">
        function <span class="apidocSignatureSpan">jugglingdb.</span>BaseSQL
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseSQL() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema" id="apidoc.element.jugglingdb.Schema">
        function <span class="apidocSignatureSpan">jugglingdb.</span>Schema
        <span class="apidocSignatureSpan">(name, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(name, settings) {
    var schema = this;
    // just save everything we get
    this.name = name;
    this.settings = settings || {};

    // Disconnected by default
    this.connected = false;
    this.connecting = false;

    // create blank models pool
    this.models = {};
    this.definitions = {};

    if (this.settings.log) {
        this.on(&#x27;log&#x27;, function(str, duration) {
            console.log(str);
        });
    }

    // and initialize schema using adapter
    // this is only one initialization entry point of adapter
    // this module should define `adapter` member of `this` (schema)
    var adapter;
    if (typeof name === &#x27;object&#x27;) {
        adapter = name;
        this.name = adapter.name;
    } else if (name.match(/^\//)) {
        // try absolute path
        adapter = require(name);
    } else if (existsSync(__dirname + &#x27;/adapters/&#x27; + name + &#x27;.js&#x27;)) {
        // try built-in adapter
        adapter = require(&#x27;./adapters/&#x27; + name);
    } else {
        // try foreign adapter
        try {
            adapter = require(&#x27;jugglingdb-&#x27; + name);
        } catch (e) {
            return console.log(&#x27;\nWARNING: JugglingDB adapter &#x22;&#x27; + name + &#x27;&#x22; is not installed,\nso your models would not work, to
 fix run:\n\n    npm install jugglingdb-&#x27; + name, &#x27;\n&#x27;);
        }
    }

    this.connecting = true;
    adapter.initialize(this, function () {

        this.adapter.log = function (query, start) {
            schema.log(query, start);
        };

        this.adapter.logger = function (query) {
            var t1 = Date.now();
            var log = this.log;
            return function (q) {
                log(q || query, t1);
            };
        };

        this.connecting = false;
        this.connected = true;
        this.emit(&#x27;connected&#x27;);

    }.bind(this));

    // we have an adaper now?
    if (!this.adapter) {
        this.emit(&#x27;disconnected&#x27;);
        throw new Error(&#x27;Adapter &#x22;&#x27; + name + &#x27;&#x22; is not defined correctly: it should define `adapter` member of schema synchronously
&#x27;);
    }

    schema.connect = function(cb) {
        var schema = this;
        schema.connecting = true;
        return new when.Promise(function(resolve, reject) {
            if (!schema.adapter.connect) {
                return process.nextTick(function() {
                    schema.connecting = false;
                    if (cb) {
                        cb(null, schema);
                    }
                    return resolve(schema);
                });
            }
            schema.adapter.connect(function(err) {
                if (err) {
                    schema.connected = false;
                    schema.connecting = false;
                    reject(err);
                    if (cb) {
                        cb(err);
                    }
                } else {
                    schema.connected = true;
                    schema.connecting = false;
                    schema.emit(&#x27;connected&#x27;);
                    resolve(schema);
                    if (cb) {
                        cb(null, schema);
                    }
                }
            });
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.init" id="apidoc.element.jugglingdb.init">
        function <span class="apidocSignatureSpan">jugglingdb.</span>init
        <span class="apidocSignatureSpan">(compound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (compound) {
    if (global.railway) {
        global.railway.orm = exports;
    } else {
        compound.orm = {
            Schema: exports.Schema,
            AbstractClass: exports.AbstractClass
        };
        if (compound.app.enabled(&#x27;noeval schema&#x27;)) {
            compound.orm.schema = exports.loadSchema(
                compound.root + &#x27;/db/schema&#x27;,
                compound.app.get(&#x27;database&#x27;),
                compound
            );
            if (compound.app.enabled(&#x27;autoupdate&#x27;)) {
                compound.on(&#x27;ready&#x27;, function() {
                    compound.orm.schema.forEach(function(s) {
                        s.autoupdate();
                        if (s.backyard) {
                            s.backyard.autoupdate();
                            s.backyard.log = s.log;
                        }
                    });
                });
            }
            return;
        }
    }

    // legacy stuff

    if (compound.version &#x3e; &#x27;1.1.5-15&#x27;) {
        compound.on(&#x27;after routes&#x27;, initialize);
    } else {
        initialize();
    }

    function initialize() {
        var railway = &#x27;./lib/railway&#x27;, init;
        try {
            init = require(railway);
        } catch (e) {
            console.log(e.stack);
        }
        if (init) {
            init(compound);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list" id="apidoc.element.jugglingdb.list">
        function <span class="apidocSignatureSpan">jugglingdb.</span>list
        <span class="apidocSignatureSpan">(data, type, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(data, type, parent) {
    var list = this;
    if (!(list instanceof List)) {
        return new List(data);
    }

    if (data &#x26;&#x26; data instanceof List) data = data.items;

    Object.defineProperty(list, &#x27;parent&#x27;, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: parent
    });

    Object.defineProperty(list, &#x27;nextid&#x27;, {
        writable: true,
        enumerable: false,
        value: 1
    });

    var Item = ListItem;
    if (typeof type === &#x27;object&#x27; &#x26;&#x26; type.constructor.name === &#x27;Array&#x27;) {
        Item = type[0] || ListItem;
    }

    data = list.items = data || [];
    Object.defineProperty(list, &#x27;ItemType&#x27;, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: Item
    });

    if (&#x27;string&#x27; === typeof data) {
        try {
            list.items = data = JSON.parse(data);
        } catch(e) {
            list.items = data = [];
        }
    }

    data.forEach(function(item, i) {
        data[i] = new Item(item, list);
        Object.defineProperty(list, data[i].id, {
            writable: true,
            enumerable: false,
            configurable: true,
            value: data[i]
        });
        if (list.nextid &#x3c;= data[i].id) {
            list.nextid = data[i].id + 1;
        }
    });

    Object.defineProperty(list, &#x27;length&#x27;, {
        enumerable: false,
        configurable: true,
        get: function() {
            return list.items.length;
        }
    });

    return list;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.loadSchema" id="apidoc.element.jugglingdb.loadSchema">
        function <span class="apidocSignatureSpan">jugglingdb.</span>loadSchema
        <span class="apidocSignatureSpan">(filename, settings, compound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadSchema = function (filename, settings, compound) {
    var schema = [];
    var definitions = require(filename);
    Object.keys(definitions).forEach(function(k) {
        var conf = settings[k];
        if (!conf) {
            console.log(&#x27;No config found for &#x27; + k + &#x27; schema, using in-memory schema&#x27;);
            conf = {driver: &#x27;memory&#x27;};
        }
        schema[k] = new Schema(conf.driver, conf);
        schema[k].on(&#x27;define&#x27;, function(m, name, prop, sett) {
            compound.models[name] = m;
            if (conf.backyard) {
                schema[k].backyard.define(name, prop, sett);
            }
        });
        schema[k].name = k;
        schema.push(schema[k]);
        if (conf.backyard) {
            schema[k].backyard = new Schema(conf.backyard.driver, conf.backyard);
        }
        if (&#x27;function&#x27; === typeof definitions[k]) {
            define(schema[k], definitions[k]);
            if (conf.backyard) {
                define(schema[k].backyard, definitions[k]);
            }
        }
    });

    return schema;

    function define(db, def) {
        def(db, compound);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    global.railway.orm = exports;
} else {
    compound.orm = {
        Schema: exports.Schema,
        AbstractClass: exports.AbstractClass
    };
    if (compound.app.enabled(&#x27;noeval schema&#x27;)) {
        compound.orm.schema = exports.<span class="apidocCodeKeywordSpan">loadSchema</span>(
            compound.root + &#x27;/db/schema&#x27;,
            compound.app.get(&#x27;database&#x27;),
            compound
        );
        if (compound.app.enabled(&#x27;autoupdate&#x27;)) {
            compound.on(&#x27;ready&#x27;, function() {
                compound.orm.schema.forEach(function(s) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.test" id="apidoc.element.jugglingdb.test">
        function <span class="apidocSignatureSpan">jugglingdb.</span>test
        <span class="apidocSignatureSpan">(exportCasesHere, schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testSchema(exportCasesHere, schema) {

    batch = exportCasesHere;
    schemaName = schema.name;
    if (schema.name.match(/^\/.*\/test\/\.\.$/)) {
        schemaName = schemaName.split(&#x27;/&#x27;).slice(-3).shift();
    }
    var start;

    batch[&#x27;should connect to database&#x27;] = function (test) {
        start = Date.now();
        if (schema.connected) return test.done();
        schema.on(&#x27;connected&#x27;, test.done);
    };

    schema.log = function (a) {
        console.log(a);
        nbSchemaRequests++;
    };

    batch[schemaName] = {};

    testOrm(schema);

    batch[&#x27;all tests done&#x27;] = function (test) {
        test.done();
        process.nextTick(allTestsDone);
    };

    function allTestsDone() {
        schema.disconnect();
        console.log(&#x27;Test done in %dms\n&#x27;, Date.now() - start);
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.AbstractClass" id="apidoc.module.jugglingdb.AbstractClass">module jugglingdb.AbstractClass</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.AbstractClass" id="apidoc.element.jugglingdb.AbstractClass.AbstractClass">
        function <span class="apidocSignatureSpan">jugglingdb.</span>AbstractClass
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">[Model undefined]</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass._forDB" id="apidoc.element.jugglingdb.AbstractClass._forDB">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>_forDB
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_forDB = function (data) {
    if (!data) return;
    var res = {};
    var definition = this.schema.definitions[this.modelName].properties;
    Object.keys(data).forEach(function (propName) {
        var val;
        var typeName = this.whatTypeName(propName);
        if (!typeName &#x26;&#x26; !data[propName] instanceof Array) {
            return;
        }
        val = data[propName];
        if (definition[propName] &#x26;&#x26; definition[propName].name) {
          // Use different name for DB field/column
          res[definition[propName].name] = val;
        } else {
          res[propName] = val;
        }
    }.bind(this));
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass._fromDB" id="apidoc.element.jugglingdb.AbstractClass._fromDB">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>_fromDB
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fromDB = function (data) {
    if (!data) return;
    var definition = this.schema.definitions[this.modelName].properties;
    var propNames = Object.keys(data);
    Object.keys(definition).forEach(function (defPropName) {
      var customName = definition[defPropName].name;
      if (customName &#x26;&#x26; propNames.indexOf(customName) !== -1) {
        data[defPropName] = data[customName];
        delete data[customName];
      }
    });
    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.all" id="apidoc.element.jugglingdb.AbstractClass.all">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Common API methods

// just instantiate model
new Post
// save model (of course async)
Post.create(cb);
// all posts
Post.<span class="apidocCodeKeywordSpan">all</span>(cb)
// all posts by user
Post.all({where: {userId: user.id}, order: &#x27;id&#x27;, limit: 10, skip: 20}, cb);
// the same as prev
user.posts(cb)
// get one latest post
Post.findOne({where: {published: true}, order: &#x27;date DESC&#x27;}, cb);
// same as new Post({userId: user.id});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.belongsTo" id="apidoc.element.jugglingdb.AbstractClass.belongsTo">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>belongsTo
        <span class="apidocSignatureSpan">(anotherClass, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsTo = function (anotherClass, params) {
    params = params || {};
    if (&#x27;string&#x27; === typeof anotherClass) {
        params.as = anotherClass;
        if (params.model) {
            anotherClass = params.model;
        } else {
            var anotherClassName = anotherClass.toLowerCase();
            for(var name in this.schema.models) {
                if (name.toLowerCase() === anotherClassName) {
                    anotherClass = this.schema.models[name];
                }
            }
        }
    }
    var methodName = params.as || i8n.camelize(anotherClass.modelName, true);
    var fk = params.foreignKey || methodName + &#x27;Id&#x27;;

    this.relations[methodName] = {
        type: &#x27;belongsTo&#x27;,
        keyFrom: fk,
        keyTo: &#x27;id&#x27;,
        modelTo: anotherClass,
        multiple: false
    };

    this.schema.defineForeignKey(this.modelName, fk, anotherClass.modelName);
    this.prototype.__finders__ = this.prototype.__finders__ || {};

    this.prototype.__finders__[methodName] = function (id, cb) {
        if (id === null) {
            cb(null, null);
            return;
        }
        anotherClass.find(id, function (err,inst) {
            if (err) {
                return cb(err);
            }
            if (!inst) {
                return cb(null, null);
            }
            if (inst.id.toString() === this[fk].toString()) {
                cb(null, inst);
            } else {
                cb(new Error(&#x27;Permission denied&#x27;));
            }
        }.bind(this));
    };

    this.prototype[methodName] = function (refresh, p) {
        if (arguments.length === 1) {
            p = refresh;
            refresh = false;
        } else if (arguments.length &#x3e; 2) {
            throw new Error(&#x27;Method can\&#x27;t be called with more than two arguments&#x27;);
        }
        var self = this;
        var cachedValue;
        if (!refresh &#x26;&#x26; this.__cachedRelations &#x26;&#x26; (typeof this.__cachedRelations[methodName] !== &#x27;undefined&#x27;)) {
            cachedValue = this.__cachedRelations[methodName];
        }
        if (p instanceof Model) { // acts as setter
            this[fk] = p.id;
            this.__cachedRelations[methodName] = p;
        } else if (typeof p === &#x27;function&#x27;) { // acts as async getter
            if (typeof cachedValue === &#x27;undefined&#x27;) {
                this.__finders__[methodName].apply(self, [this[fk], function(err, inst) {
                    if (!err) {
                        self.__cachedRelations[methodName] = inst;
                    }
                    p(err, inst);
                }]);
                return this[fk];
            } else {
                p(null, cachedValue);
                return cachedValue;
            }
        } else if (typeof p === &#x27;undefined&#x27;) { // acts as sync getter
            return this[fk];
        } else { // setter
            this[fk] = p;
            delete this.__cachedRelations[methodName];
        }
    };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// setup relationships
User.hasMany(Post,   {as: &#x27;posts&#x27;,  foreignKey: &#x27;userId&#x27;});
// creates instance methods:
// user.posts(conds)
// user.posts.build(data) // like new Post({userId: user.id});
// user.posts.create(data) // build and save

Post.<span class="apidocCodeKeywordSpan">belongsTo</span>(User, {as: &#x27;author&#x27;, foreignKey: &#x27;userId&#x27;});
// creates instance methods:
// post.author(callback) -- getter when called with function
// post.author() -- sync getter when called without params
// post.author(user) -- setter when called with object

User.hasAndBelongsToMany(&#x27;groups&#x27;);
// user.groups(callback) - get groups of user
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.count" id="apidoc.element.jugglingdb.AbstractClass.count">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// same as new Post({userId: user.id});
user.posts.build
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.find(1, cb)
// count instances
User.<span class="apidocCodeKeywordSpan">count</span>([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
Post.update({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.create" id="apidoc.element.jugglingdb.AbstractClass.create">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
// setup relationships
User.hasMany(Post,   {as: &#x27;posts&#x27;,  foreignKey: &#x27;userId&#x27;});
// creates instance methods:
// user.posts(conds)
// user.posts.build(data) // like new Post({userId: user.id});
// user.posts.<span class="apidocCodeKeywordSpan">create</span>(data) // build and save

Post.belongsTo(User, {as: &#x27;author&#x27;, foreignKey: &#x27;userId&#x27;});
// creates instance methods:
// post.author(callback) -- getter when called with function
// post.author() -- sync getter when called without params
// post.author(user) -- setter when called with object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.defineProperty" id="apidoc.element.jugglingdb.AbstractClass.defineProperty">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
    this.schema.defineProperty(this.modelName, prop, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var list = this;
if (!(list instanceof List)) {
    return new List(data);
}

if (data &#x26;&#x26; data instanceof List) data = data.items;

Object.<span class="apidocCodeKeywordSpan">defineProperty</span>(list, &#x27;parent&#x27;, {
    writable: false,
    enumerable: false,
    configurable: false,
    value: parent
});

Object.defineProperty(list, &#x27;nextid&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.destroyAll" id="apidoc.element.jugglingdb.AbstractClass.destroyAll">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>destroyAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// find instance by id
User.find(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.<span class="apidocCodeKeywordSpan">destroyAll</span>(cb);
// update a post (currently only on the mysql adapter)
Post.update({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
Post.update([{ where:{id:&#x27;1&#x27;}, update:{ published:false }},{ where:{id:&#x27;2&#x27;}, update:{ published:true }}], cb
);
```

SEE [model(3)](http://jugglingdb.co/model.3.html) for more information about
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.exists" id="apidoc.element.jugglingdb.AbstractClass.exists">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>exists
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.find" id="apidoc.element.jugglingdb.AbstractClass.find">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// get one latest post
Post.findOne({where: {published: true}, order: &#x27;date DESC&#x27;}, cb);
// same as new Post({userId: user.id});
user.posts.build
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.<span class="apidocCodeKeywordSpan">find</span>(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.findOne" id="apidoc.element.jugglingdb.AbstractClass.findOne">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>findOne
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// all posts
Post.all(cb)
// all posts by user
Post.all({where: {userId: user.id}, order: &#x27;id&#x27;, limit: 10, skip: 20}, cb);
// the same as prev
user.posts(cb)
// get one latest post
Post.<span class="apidocCodeKeywordSpan">findOne</span>({where: {published: true}, order: &#x27;date DESC&#x27;}, cb);
// same as new Post({userId: user.id});
user.posts.build
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.find(1, cb)
// count instances
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.findOrCreate" id="apidoc.element.jugglingdb.AbstractClass.findOrCreate">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
    if (typeof query === &#x27;undefined&#x27;) {
        query = {where: {}};
    }
    if (typeof data === &#x27;function&#x27; || typeof data === &#x27;undefined&#x27;) {
        callback = data;
        data = query &#x26;&#x26; query.where;
    }
    if (typeof callback === &#x27;undefined&#x27;) {
        callback = function () {};
    }

    var t = this;
    this.findOne(query, function (err, record) {
        if (err) return callback(err);
        if (record) return callback(null, record);
        t.create(data, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        data = {};
    }
    var query = {};
    query[fk] = this.id;
    data[params.through.relationNameFor(fk)] = this;
    query[fk2] = acInst.id || acInst;
    data[params.through.relationNameFor(fk2)] = acInst;
    params.through.<span class="apidocCodeKeywordSpan">findOrCreate</span>({where: query}, data, done);
};
scopeMethods.remove = function(acInst, done) {
    var q = {};
    q[fk] = this.id;
    q[fk2] = acInst.id || acInst;
    params.through.findOne({where: q}, function(err, d) {
        if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.hasAndBelongsToMany" id="apidoc.element.jugglingdb.AbstractClass.hasAndBelongsToMany">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>hasAndBelongsToMany
        <span class="apidocSignatureSpan">(anotherClass, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasAndBelongsToMany(anotherClass, params) {
    params = params || {};
    var models = this.schema.models;

    if (&#x27;string&#x27; === typeof anotherClass) {
        params.as = anotherClass;
        if (params.model) {
            anotherClass = params.model;
        } else {
            anotherClass = lookupModel(i8n.singularize(anotherClass)) ||
                anotherClass;
        }
        if (typeof anotherClass === &#x27;string&#x27;) {
            throw new Error(&#x27;Could not find &#x22;&#x27; + anotherClass + &#x27;&#x22; relation for &#x27; + this.modelName);
        }
    }

    if (!params.through) {
        var name1 = this.modelName + anotherClass.modelName;
        var name2 = anotherClass.modelName + this.modelName;
        params.through = lookupModel(name1) || lookupModel(name2) ||
            this.schema.define(name1);
    }
    params.through.belongsTo(this);
    params.through.belongsTo(anotherClass);

    this.hasMany(anotherClass, {as: params.as, through: params.through});

    function lookupModel(modelName) {
        var lookupClassName = modelName.toLowerCase();
        for (var name in models) {
            if (name.toLowerCase() === lookupClassName) {
                return models[name];
            }
        }
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Post.belongsTo(User, {as: &#x27;author&#x27;, foreignKey: &#x27;userId&#x27;});
// creates instance methods:
// post.author(callback) -- getter when called with function
// post.author() -- sync getter when called without params
// post.author(user) -- setter when called with object

User.<span class="apidocCodeKeywordSpan">hasAndBelongsToMany</span>(&#x27;groups&#x27;);
// user.groups(callback) - get groups of user
// user.groups.create(data, callback) - create new group and connect with user
// user.groups.add(group, callback) - connect existing group with user
// user.groups.remove(group, callback) - remove connection between group and user

schema.automigrate(); // required only for mysql and postgres NOTE: it will drop User and Post tables
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.hasMany" id="apidoc.element.jugglingdb.AbstractClass.hasMany">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>hasMany
        <span class="apidocSignatureSpan">(anotherClass, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasMany(anotherClass, params) {
    var thisClass = this, thisClassName = this.modelName;
    params = params || {};
    if (typeof anotherClass === &#x27;string&#x27;) {
        params.as = anotherClass;
        if (params.model) {
            anotherClass = params.model;
        } else {
            var anotherClassName = i8n.singularize(anotherClass).toLowerCase();
            for(var name in this.schema.models) {
                if (name.toLowerCase() === anotherClassName) {
                    anotherClass = this.schema.models[name];
                }
            }
        }
    }
    var methodName = params.as ||
        i8n.camelize(i8n.pluralize(anotherClass.modelName), true);
    var fk = params.foreignKey || i8n.camelize(thisClassName + &#x27;_id&#x27;, true);

    this.relations[methodName] = {
        type: &#x27;hasMany&#x27;,
        keyFrom: &#x27;id&#x27;,
        keyTo: fk,
        modelTo: anotherClass,
        multiple: true
    };
    // each instance of this class should have method named
    // pluralize(anotherClass.modelName)
    // which is actually just anotherClass.all({where: {thisModelNameId: this.id}}, cb);
    var scopeMethods = {
        find: find,
        destroy: destroy
    };
    if (params.through) {

        // Append through relation, like modelTo
        this.relations[methodName].modelThrough = params.through;

        var fk2 = i8n.camelize(anotherClass.modelName + &#x27;_id&#x27;, true);
        scopeMethods.create = function create(data, done) {
            if (typeof data !== &#x27;object&#x27;) {
                done = data;
                data = {};
            }
            if (&#x27;function&#x27; !== typeof done) {
                done = function() {};
            }
            var self = this;
            var id = this.id;
            anotherClass.create(data, function(err, ac) {
                if (err) return done(err, ac);
                var d = {};
                d[params.through.relationNameFor(fk)] = self;
                d[params.through.relationNameFor(fk2)] = ac;
                params.through.create(d, function(e) {
                    if (e) {
                        ac.destroy(function() {
                            done(e);
                        });
                    } else {
                        done(err, ac);
                    }
                });
            });
        };
        scopeMethods.add = function(acInst, data, done) {
            if (typeof data === &#x27;function&#x27;) {
                done = data;
                data = {};
            }
            var query = {};
            query[fk] = this.id;
            data[params.through.relationNameFor(fk)] = this;
            query[fk2] = acInst.id || acInst;
            data[params.through.relationNameFor(fk2)] = acInst;
            params.through.findOrCreate({where: query}, data, done);
        };
        scopeMethods.remove = function(acInst, done) {
            var q = {};
            q[fk] = this.id;
            q[fk2] = acInst.id || acInst;
            params.through.findOne({where: q}, function(err, d) {
                if (err) {
                    return done(err);
                }
                if (!d) {
                    return done();
                }
                d.destroy(done);
            });
        };
        delete scopeMethods.destroy;
    }
    defineScope(this.prototype, params.through || anotherClass, methodName, function () {
        var filter = {};
        filter.where = {};
        filter.where[fk] = this.id;
        if (params.through) {
            filter.collect = i8n.camelize(anotherClass.modelName, true);
            filter.include = filter.collect;
        }
        return filter;
    }, scopeMethods);

    if (!params.through) {
        // obviously, anotherClass should have attribute called `fk`
        anotherClass.schema.defineForeignKey(anotherClass.modelName, fk, this.modelName);
    }

    function find(id, cb) {
        anotherClass.find(id, function (err, inst) {
            if (err) return cb(err);
            if (!inst) return cb(new Error(&#x27;Not found&#x27;));
            if (inst[fk] &#x26;&#x26; inst[fk].toStri ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
schema.models.Post;
```

SEE [schema(3)](http://jugglingdb.co/schema.3.html) for details schema usage.

```javascript
// setup relationships
User.<span class="apidocCodeKeywordSpan">hasMany</span>(Post,   {as: &#x27;posts&#x27;,  foreignKey: &#x27;userId&#x27;});
// creates instance methods:
// user.posts(conds)
// user.posts.build(data) // like new Post({userId: user.id});
// user.posts.create(data) // build and save

Post.belongsTo(User, {as: &#x27;author&#x27;, foreignKey: &#x27;userId&#x27;});
// creates instance methods:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.include" id="apidoc.element.jugglingdb.AbstractClass.include">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>include
        <span class="apidocSignatureSpan">(objects, include, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">include = function (objects, include, cb) {

    if ((include.constructor.name == &#x27;Array&#x27; &#x26;&#x26; include.length === 0) || (include.constructor.name == &#x27;Object&#x27; &#x26;&#x26; Object.keys(include
).length === 0)) {
        cb(null, objects);
        return;
    }

    include = processIncludeJoin(include);

    var keyVals = {};
    var objsByKeys = {};

    var nbCallbacks = 0;
    var totalCallbacks = 0;

    for (var i = 0; i &#x3c; include.length; i++) {
        var callback = processIncludeItem(this, objects, include[i], keyVals, objsByKeys);
        if (callback !== null) {
            totalCallbacks++;
            if (callback instanceof Error) {
                cb(callback);
            } else {
                includeItemCallback(callback);
            }
        }
    }

    if (totalCallbacks === 0) {
        cb(null, objects);
    }

    function includeItemCallback(itemCb) {
        nbCallbacks++;
        itemCb(function () {
            nbCallbacks--;
            if (nbCallbacks === 0) {
                cb(null, objects);
            }
        });
    }

    function processIncludeJoin(ij) {
        if (typeof ij === &#x27;string&#x27;) {
            ij = [ij];
        }
        if (ij.constructor.name === &#x27;Object&#x27;) {
            var newIj = [];
            for (var key in ij) {
                var obj = {};
                obj[key] = ij[key];
                newIj.push(obj);
            }
            return newIj;
        }
        return ij;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {Array} objects - array of instances
* @param {String}, {Object} or {Array} include - which relations you want to load.
* @param {Function} cb - Callback called when relations are loaded
*
* Examples:
*
* - User.<span class="apidocCodeKeywordSpan">include</span>(users, &#x27;posts&#x27;, function() {}); will load all users posts
with only one additional request.
* - User.include(users, [&#x27;posts&#x27;], function() {}); // same
* - User.include(users, [&#x27;posts&#x27;, &#x27;passports&#x27;], function() {}); // will load all users posts and passports with
 two
*     additional requests.
* - Passport.include(passports, {owner: &#x27;posts&#x27;}, function() {}); // will load all passports owner (users), and all
*     posts of each owner loaded
* - Passport.include(passports, {owner: [&#x27;posts&#x27;, &#x27;passports&#x27;]}); // ...
* - Passport.include(passports, {owner: [{posts: &#x27;images&#x27;}, &#x27;passports&#x27;]}); // ...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.iterate" id="apidoc.element.jugglingdb.AbstractClass.iterate">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>iterate
        <span class="apidocSignatureSpan">(filter, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(filter, iterator, callback) {
    var Model = this;
    if (&#x27;function&#x27; === typeof filter) {
        if (&#x27;function&#x27; === typeof iterator) {
            callback = iterator;
        }
        iterator = filter;
        filter = {};
    }

    var concurrent = filter.concurrent;
    delete filter.concurrent;
    var limit = filter.limit;
    var batchSize = filter.limit = filter.batchSize || 1000;
    var batchNumber = filter.batchNumber || -1;

    nextBatch();

    function nextBatch() {
        // console.log(batchNumber);
        batchNumber += 1;
        filter.skip = filter.offset = batchNumber * batchSize;
        if (limit &#x3c; batchSize) {
            if (limit &#x3c;= 0) {
                return done();
            } else {
                filter.limit = limit;
            }
        }
        limit -= batchSize;
        Model.all(filter).then(function(collection) {
            if (collection.length === 0) {
                return done();
            }
            var i = 0, wait;
            if (concurrent) {
                wait = collection.length;
                collection.forEach(function(obj, i) {
                    iterator(obj, next, filter.offset + i);
                    obj = null;
                });
                collection = null;
            } else {
                nextItem();
            }
            function next() {
                if (--wait === 0) {
                    nextBatch();
                }
            }
            function nextItem(err) {
                if (err) {
                    return done(err);
                }
                var item = collection[i];
                if (i &#x3e; collection.length - 1) {
                    return nextBatch();
                }
                i += 1;
                setImmediate(function() {
                    iterator(item, nextItem, filter.offset + i);
                });
            }
        }).catch(done);
    }

    function done(err) {
        if (&#x27;function&#x27; === typeof callback) {
            callback(err);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.relationNameFor" id="apidoc.element.jugglingdb.AbstractClass.relationNameFor">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>relationNameFor
        <span class="apidocSignatureSpan">(foreignKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function relationNameFor(foreignKey) {
    for (var rel in this.relations) {
        if (this.relations[rel].type === &#x27;belongsTo&#x27; &#x26;&#x26; this.relations[rel].keyFrom === foreignKey) {
            return rel;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    done = function() {};
}
var self = this;
var id = this.id;
anotherClass.create(data, function(err, ac) {
    if (err) return done(err, ac);
    var d = {};
    d[params.through.<span class="apidocCodeKeywordSpan">relationNameFor</span>(fk)] = self;
    d[params.through.relationNameFor(fk2)] = ac;
    params.through.create(d, function(e) {
        if (e) {
            ac.destroy(function() {
                done(e);
            });
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.scope" id="apidoc.element.jugglingdb.AbstractClass.scope">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>scope
        <span class="apidocSignatureSpan">(name, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scope = function (name, params) {
    defineScope(this, this, name, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.toString" id="apidoc.element.jugglingdb.AbstractClass.toString">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return &#x27;[Model &#x27; + this.modelName + &#x27;]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (existsSync(schemaFile + &#x27;coffee&#x27;)) {
    schemaFile += &#x27;coffee&#x27;;
} else {
    schemaFile = false;
}

if (schemaFile) {
    var code = fs.readFileSync(schemaFile).<span class="apidocCodeKeywordSpan">toString</span>();
    if (schemaFile.match(/\.coffee$/)) {
        code = require(&#x27;coffee-script&#x27;).compile(code);
    }
    /*jshint evil: true */
    var fn = new Function(&#x27;context&#x27;, &#x27;require&#x27;, &#x27;with(context){(function(){&#x27; + code + &#x27;})()}&#
x27;);
    fn(context, require);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.update" id="apidoc.element.jugglingdb.AbstractClass.update">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// count instances
User.count([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
Post.<span class="apidocCodeKeywordSpan">update</span>({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
Post.update([{ where:{id:&#x27;1&#x27;}, update:{ published:false }},{ where:{id:&#x27;2&#x27;}, update:{ published:true }}], cb
);
```

SEE [model(3)](http://jugglingdb.co/model.3.html) for more information about
jugglingdb Model API. Or `man jugglingdb-model` in terminal.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.updateOrCreate" id="apidoc.element.jugglingdb.AbstractClass.updateOrCreate">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>updateOrCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.upsert" id="apidoc.element.jugglingdb.AbstractClass.upsert">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>upsert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validate" id="apidoc.element.jugglingdb.AbstractClass.validate">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Validate using custom validator
*
* Default error message: is invalid
*
* Example:
*
*     User.<span class="apidocCodeKeywordSpan">validate</span>(&#x27;name&#x27;, customValidator, {message: &#x27;Bad name&#x27;});
*     function customValidator(err) {
*         if (this.name === &#x27;bad&#x27;) err();
*     });
*     var user = new User({name: &#x27;Peter&#x27;});
*     user.isValid(); // true
*     user.name = &#x27;bad&#x27;;
*     user.isValid(); // false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validateAsync" id="apidoc.element.jugglingdb.AbstractClass.validateAsync">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Validate using custom async validator
*
* Default error message: is invalid
*
* Example:
*
*     User.<span class="apidocCodeKeywordSpan">validateAsync</span>(&#x27;name&#x27;, customValidator, {message: &#x27;Bad name&#
x27;});
*     function customValidator(err, done) {
*         process.nextTick(function () {
*             if (this.name === &#x27;bad&#x27;) err();
*             done();
*         });
*     });
*     var user = new User({name: &#x27;Peter&#x27;});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesExclusionOf" id="apidoc.element.jugglingdb.AbstractClass.validatesExclusionOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript

// Setup validations
User.validatesPresenceOf(&#x27;name&#x27;, &#x27;email&#x27;)
User.validatesLengthOf(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is too short&#x27;}});
User.validatesInclusionOf(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27;]});
User.<span class="apidocCodeKeywordSpan">validatesExclusionOf</span>(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27
;, &#x27;admin&#x27;]});
User.validatesNumericalityOf(&#x27;age&#x27;, {int: true});
User.validatesUniquenessOf(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27;});

user.isValid(function (valid) {
if (!valid) {
    user.errors // hash of errors {attr: [errmessage, errmessage, ...], attr: ...}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesFormatOf" id="apidoc.element.jugglingdb.AbstractClass.validatesFormatOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesInclusionOf" id="apidoc.element.jugglingdb.AbstractClass.validatesInclusionOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
jugglingdb Model API. Or `man jugglingdb-model` in terminal.

```javascript

// Setup validations
User.validatesPresenceOf(&#x27;name&#x27;, &#x27;email&#x27;)
User.validatesLengthOf(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is too short&#x27;}});
User.<span class="apidocCodeKeywordSpan">validatesInclusionOf</span>(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27
;]});
User.validatesExclusionOf(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27;, &#x27;admin&#x27;]});
User.validatesNumericalityOf(&#x27;age&#x27;, {int: true});
User.validatesUniquenessOf(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27;});

user.isValid(function (valid) {
if (!valid) {
    user.errors // hash of errors {attr: [errmessage, errmessage, ...], attr: ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesLengthOf" id="apidoc.element.jugglingdb.AbstractClass.validatesLengthOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
SEE [model(3)](http://jugglingdb.co/model.3.html) for more information about
jugglingdb Model API. Or `man jugglingdb-model` in terminal.

```javascript

// Setup validations
User.validatesPresenceOf(&#x27;name&#x27;, &#x27;email&#x27;)
User.<span class="apidocCodeKeywordSpan">validatesLengthOf</span>(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is
 too short&#x27;}});
User.validatesInclusionOf(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27;]});
User.validatesExclusionOf(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27;, &#x27;admin&#x27;]});
User.validatesNumericalityOf(&#x27;age&#x27;, {int: true});
User.validatesUniquenessOf(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27;});

user.isValid(function (valid) {
if (!valid) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesNumericalityOf" id="apidoc.element.jugglingdb.AbstractClass.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript

// Setup validations
User.validatesPresenceOf(&#x27;name&#x27;, &#x27;email&#x27;)
User.validatesLengthOf(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is too short&#x27;}});
User.validatesInclusionOf(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27;]});
User.validatesExclusionOf(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27;, &#x27;admin&#x27;]});
User.<span class="apidocCodeKeywordSpan">validatesNumericalityOf</span>(&#x27;age&#x27;, {int: true});
User.validatesUniquenessOf(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27;});

user.isValid(function (valid) {
    if (!valid) {
        user.errors // hash of errors {attr: [errmessage, errmessage, ...], attr: ...}
    }
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesPresenceOf" id="apidoc.element.jugglingdb.AbstractClass.validatesPresenceOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

SEE [model(3)](http://jugglingdb.co/model.3.html) for more information about
jugglingdb Model API. Or `man jugglingdb-model` in terminal.

```javascript

// Setup validations
User.<span class="apidocCodeKeywordSpan">validatesPresenceOf</span>(&#x27;name&#x27;, &#x27;email&#x27;)
User.validatesLengthOf(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is too short&#x27;}});
User.validatesInclusionOf(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27;]});
User.validatesExclusionOf(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27;, &#x27;admin&#x27;]});
User.validatesNumericalityOf(&#x27;age&#x27;, {int: true});
User.validatesUniquenessOf(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27;});

user.isValid(function (valid) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.validatesUniquenessOf" id="apidoc.element.jugglingdb.AbstractClass.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
    configure(this, name, arguments, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Setup validations
User.validatesPresenceOf(&#x27;name&#x27;, &#x27;email&#x27;)
User.validatesLengthOf(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is too short&#x27;}});
User.validatesInclusionOf(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27;]});
User.validatesExclusionOf(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27;, &#x27;admin&#x27;]});
User.validatesNumericalityOf(&#x27;age&#x27;, {int: true});
User.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27
;});

user.isValid(function (valid) {
    if (!valid) {
        user.errors // hash of errors {attr: [errmessage, errmessage, ...], attr: ...}
    }
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.whatTypeName" id="apidoc.element.jugglingdb.AbstractClass.whatTypeName">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.</span>whatTypeName
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whatTypeName = function (propName) {
    var prop = this.schema.definitions[this.modelName].properties[propName];
    if (!prop || !prop.type) {
        return null;
        // throw new Error(&#x27;Undefined type for &#x27; + this.modelName + &#x27;:&#x27; + propName);
    }
    return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.AbstractClass.prototype" id="apidoc.module.jugglingdb.AbstractClass.prototype">module jugglingdb.AbstractClass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype._adapter" id="apidoc.element.jugglingdb.AbstractClass.prototype._adapter">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>_adapter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_adapter = function () {
    return this.schema.adapter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype._initProperties" id="apidoc.element.jugglingdb.AbstractClass.prototype._initProperties">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>_initProperties
        <span class="apidocSignatureSpan">(data, applySetters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initProperties = function (data, applySetters) {
    var self = this;
    var ctor = this.constructor;
    var ds = ctor.schema.definitions[ctor.modelName];
    var properties = ds.properties;
    data = data || {};

    Object.defineProperty(this, &#x27;__cachedRelations&#x27;, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: {}
    });

    Object.defineProperty(this, &#x27;__data&#x27;, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: {}
    });

    Object.defineProperty(this, &#x27;__dataWas&#x27;, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: {}
    });

    if (data.__cachedRelations) {
        this.__cachedRelations = data.__cachedRelations;
    }

    for (var i in data) {
        if (i in properties) {
            this.__data[i] = this.__dataWas[i] = data[i];
        } else if (i in ctor.relations) {
            this.__data[ctor.relations[i].keyFrom] = this.__dataWas[i] = data[i][ctor.relations[i].keyTo];
            this.__cachedRelations[i] = data[i];
        }
    }

    if (applySetters === true) {
        Object.keys(data).forEach(function (attr) {
            self[attr] = data[attr];
        });
    }

    ctor.forEachProperty(function (attr) {

        if (&#x27;undefined&#x27; === typeof self.__data[attr]) {
            self.__data[attr] = self.__dataWas[attr] = getDefault(attr);
        } else {
            self.__dataWas[attr] = self.__data[attr];
        }

    });

    ctor.forEachProperty(function (attr) {

        var type = properties[attr].type;

        if (BASE_TYPES.indexOf(type.name) === -1) {
            if (typeof self.__data[attr] !== &#x27;object&#x27; &#x26;&#x26; self.__data[attr]) {
                try {
                    self.__data[attr] = JSON.parse(self.__data[attr] + &#x27;&#x27;);
                } catch (e) {
                    self.__data[attr] = String(self.__data[attr]);
                }
            }
            if (type.name === &#x27;Array&#x27; || typeof type === &#x27;object&#x27; &#x26;&#x26; type.constructor.name === &#x27;Array&#x27;) {
                self.__data[attr] = new List(self.__data[attr], type, self);
            }
        }

    });

    function getDefault(attr) {
        var def = properties[attr][&#x27;default&#x27;];
        if (isdef(def)) {
            if (typeof def === &#x27;function&#x27;) {
                return def();
            } else {
                return def;
            }
        } else {
            return undefined;
        }
    }

    this.trigger(&#x27;initialize&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.destroy" id="apidoc.element.jugglingdb.AbstractClass.prototype.destroy">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.find(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.<span class="apidocCodeKeywordSpan">destroy</span>(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
Post.update({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
Post.update([{ where:{id:&#x27;1&#x27;}, update:{ published:false }},{ where:{id:&#x27;2&#x27;}, update:{ published:true }}], cb
);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.fromObject" id="apidoc.element.jugglingdb.AbstractClass.prototype.fromObject">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>fromObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromObject = function (obj) {
    Object.keys(obj).forEach(function (key) {
        this[key] = obj[key];
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.inspect" id="apidoc.element.jugglingdb.AbstractClass.prototype.inspect">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return util.inspect(this.__data, false, 4, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    return list;

}

List.prototype.inspect = function() {
    return util.<span class="apidocCodeKeywordSpan">inspect</span>(this.items);
};

var _;
try {
    var underscore = &#x27;underscore&#x27;;
    _ = require(underscore);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.isNewRecord" id="apidoc.element.jugglingdb.AbstractClass.prototype.isNewRecord">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>isNewRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNewRecord = function () {
    return !this.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.isValid" id="apidoc.element.jugglingdb.AbstractClass.prototype.isValid">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>isValid
        <span class="apidocSignatureSpan">(callback, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValid = function (callback, data) {
    var valid = true, inst = this, wait = 0, async = false;

    callback = callback || NOOP;

    // callback only needs one arguments, then the signature is `callback(valid)`
    // convert it to standard node.js callback style
    if (callback.length &#x3c; 2) {
        var _callback = callback;
        callback = function (err, valid) {
            _callback(valid);
        };
    }

    // exit with success when no errors
    if (!this.constructor._validations) {
        cleanErrors(this);
        if (callback) {
            this.trigger(&#x27;validate&#x27;, function(validationsDone) {
                validationsDone.call(inst, function() {
                    callback(null, valid);
                });
            }, data, function (err) {
                callback(err, false);
            });
        }
        return valid;
    }

    Object.defineProperty(this, &#x27;errors&#x27;, {
        enumerable: false,
        configurable: true,
        value: new Errors(this)
    });

    this.trigger(&#x27;validate&#x27;, function (validationsDone) {
        var inst = this,
            asyncFail = false;

        this.constructor._validations.forEach(function (v) {
            if (v[2] &#x26;&#x26; v[2].async) {
                async = true;
                wait += 1;
                process.nextTick(function () {
                    validationFailed(inst, v, done);
                });
            } else {
                if (validationFailed(inst, v)) {
                    valid = false;
                }
            }

        });

        if (!async) {
            validationsDone.call(inst, function() {
                if (valid) cleanErrors(inst);
                if (callback) {
                    callback(valid ? null : new ValidationError(this), valid);
                }
            });
        }

        function done(fail) {
            asyncFail = asyncFail || fail;
            if (--wait === 0) {
                validationsDone.call(inst, function () {
                    if (valid &#x26;&#x26; !asyncFail) cleanErrors(inst);
                    if (callback) {
                        callback(valid ? null : new ValidationError(this), valid &#x26;&#x26; !asyncFail);
                    }
                });
            }
        }

    }, data, function (err) {
        callback(err, false);
    });

    if (async) {
        // in case of async validation we should return undefined here,
        // because not all validations are finished yet
        return;
    } else {
        return valid;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
User.validatesPresenceOf(&#x27;name&#x27;, &#x27;email&#x27;)
User.validatesLengthOf(&#x27;password&#x27;, {min: 5, message: {min: &#x27;Password is too short&#x27;}});
User.validatesInclusionOf(&#x27;gender&#x27;, {in: [&#x27;male&#x27;, &#x27;female&#x27;]});
User.validatesExclusionOf(&#x27;domain&#x27;, {in: [&#x27;www&#x27;, &#x27;billing&#x27;, &#x27;admin&#x27;]});
User.validatesNumericalityOf(&#x27;age&#x27;, {int: true});
User.validatesUniquenessOf(&#x27;email&#x27;, {message: &#x27;email is not unique&#x27;});

user.<span class="apidocCodeKeywordSpan">isValid</span>(function (valid) {
    if (!valid) {
        user.errors // hash of errors {attr: [errmessage, errmessage, ...], attr: ...}
    }
})

```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.propertyChanged" id="apidoc.element.jugglingdb.AbstractClass.prototype.propertyChanged">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>propertyChanged
        <span class="apidocSignatureSpan">(attr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function propertyChanged(attr) {
    return this.__data[attr] !== this.__dataWas[attr];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.reload" id="apidoc.element.jugglingdb.AbstractClass.prototype.reload">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>reload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.reset" id="apidoc.element.jugglingdb.AbstractClass.prototype.reset">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    var obj = this;
    Object.keys(obj).forEach(function (k) {
        if (k !== &#x27;id&#x27; &#x26;&#x26; !obj.constructor.schema.definitions[obj.constructor.modelName].properties[k]) {
            delete obj[k];
        }
        if (obj.propertyChanged(k)) {
            obj[k] = obj[k + &#x27;_was&#x27;];
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.save" id="apidoc.element.jugglingdb.AbstractClass.prototype.save">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// user.groups.add(group, callback) - connect existing group with user
// user.groups.remove(group, callback) - remove connection between group and user

schema.automigrate(); // required only for mysql and postgres NOTE: it will drop User and Post tables

// work with models:
var user = new User;
user.<span class="apidocCodeKeywordSpan">save</span>(function (err) {
    var post = user.posts.build({title: &#x27;Hello world&#x27;});
    post.save(console.log);
});

// or just call it as function (with the same result):
var user = User();
user.save(...);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.toJSON" id="apidoc.element.jugglingdb.AbstractClass.prototype.toJSON">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    return this.toObject(false, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.toObject" id="apidoc.element.jugglingdb.AbstractClass.prototype.toObject">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>toObject
        <span class="apidocSignatureSpan">(onlySchema, cachedRelations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function (onlySchema, cachedRelations) {
    var data = {};
    var ds = this.constructor.schema.definitions[this.constructor.modelName];
    var properties = ds.properties;
    var self = this;

    this.constructor.forEachProperty(function (attr) {
        if (self[attr] instanceof List) {
            data[attr] = self[attr].toObject();
        } else if (self.__data.hasOwnProperty(attr)) {
            data[attr] = self[attr];
        } else {
            data[attr] = null;
        }
    });

    if (!onlySchema) {
        Object.keys(self).forEach(function (attr) {
            if (!data.hasOwnProperty(attr)) {
                data[attr] = self[attr];
            }
        });

        if (cachedRelations === true &#x26;&#x26; this.__cachedRelations) {
            var relations = this.__cachedRelations;
            Object.keys(relations).forEach(function (attr) {
                if (!data.hasOwnProperty(attr)) {
                    data[attr] = relations[attr];
                }
            });
        }
    }

    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.trigger" id="apidoc.element.jugglingdb.AbstractClass.prototype.trigger">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>trigger
        <span class="apidocSignatureSpan">(actionName, work, data, quit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trigger(actionName, work, data, quit) {
    var capitalizedName = capitalize(actionName);
    var beforeHook = this.constructor[&#x22;before&#x22; + capitalizedName];
    var afterHook = this.constructor[&#x22;after&#x22; + capitalizedName];
    if (actionName === &#x27;validate&#x27;) {
        beforeHook = beforeHook || this.constructor.beforeValidation;
        afterHook = afterHook || this.constructor.afterValidation;
    }
    var inst = this;

    // we only call &#x22;before&#x22; hook when we have actual action (work) to perform
    if (work) {
        if (beforeHook) {
            // before hook should be called on instance with one param: callback
            beforeHook.call(inst, function (err) {
                if (err) {
                    if (quit) {
                        quit.call(inst, err);
                    }
                    return;
                }
                // actual action also have one param: callback
                work.call(inst, next);
            }, data);
        } else {
            work.call(inst, next);
        }
    } else {
        next();
    }

    function next(done) {
        if (afterHook) {
            afterHook.call(inst, done);
        } else if (done) {
            done.call(this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };
}

// exit with success when no errors
if (!this.constructor._validations) {
    cleanErrors(this);
    if (callback) {
        this.<span class="apidocCodeKeywordSpan">trigger</span>(&#x27;validate&#x27;, function(validationsDone) {
            validationsDone.call(inst, function() {
                callback(null, valid);
            });
        }, data, function (err) {
            callback(err, false);
        });
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.updateAttribute" id="apidoc.element.jugglingdb.AbstractClass.prototype.updateAttribute">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>updateAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// beforeValidate
// afterValidate
// beforeSave
// beforeUpdate
// afterUpdate
// afterSave
// callback
user.<span class="apidocCodeKeywordSpan">updateAttribute</span>(&#x27;email&#x27;, &#x27;email@example.com&#x27;, callback);
// beforeValidate
// afterValidate
// beforeSave
// beforeUpdate
// afterUpdate
// afterSave
// callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.updateAttributes" id="apidoc.element.jugglingdb.AbstractClass.prototype.updateAttributes">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>updateAttributes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisedWrap() {
    var args = [].slice.call(arguments);
    var callback = &#x27;function&#x27; === typeof args[args.length - 1] ? args.pop() : null;
    var self = this;
    var Model = isClassMethod ? self : self.constructor;
    var queryResult;
    var promisedQuery = connection(Model.schema)
    .then(function() {
        return new when.Promise(function(resolve, reject) {
            args.push(function(err, result) {
                queryResult = result;
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
            fn.apply(self, args);
        });
    });
    if (callback) {
        promisedQuery.then(function(result) {
            callback(null, result);
        }, function(err) {
            if (&#x27;undefined&#x27; !== queryResult) {
                callback(err, queryResult);
            } else {
                callback(err);
            }
        });
    } else {
        return promisedQuery;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.AbstractClass.prototype.whatTypeName" id="apidoc.element.jugglingdb.AbstractClass.prototype.whatTypeName">
        function <span class="apidocSignatureSpan">jugglingdb.AbstractClass.prototype.</span>whatTypeName
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whatTypeName = function (propName) {
    return this.constructor.whatTypeName(propName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.BaseSQL" id="apidoc.module.jugglingdb.BaseSQL">module jugglingdb.BaseSQL</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.BaseSQL" id="apidoc.element.jugglingdb.BaseSQL.BaseSQL">
        function <span class="apidocSignatureSpan">jugglingdb.</span>BaseSQL
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseSQL() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.BaseSQL.prototype" id="apidoc.module.jugglingdb.BaseSQL.prototype">module jugglingdb.BaseSQL.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.automigrate" id="apidoc.element.jugglingdb.BaseSQL.prototype.automigrate">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>automigrate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">automigrate = function (cb) {
    var self = this;
    var wait = 0;
    Object.keys(this._models).forEach(function (model) {
        wait += 1;
        self.dropTable(model, function () {
            // console.log(&#x27;drop&#x27;, model);
            self.createTable(model, function (err) {
                // console.log(&#x27;create&#x27;, model);
                if (err) console.log(err);
                done();
            });
        });
    });
    if (wait === 0) cb();

    function done() {
        if (--wait === 0 &#x26;&#x26; cb) {
            cb();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

User.hasAndBelongsToMany(&#x27;groups&#x27;);
// user.groups(callback) - get groups of user
// user.groups.create(data, callback) - create new group and connect with user
// user.groups.add(group, callback) - connect existing group with user
// user.groups.remove(group, callback) - remove connection between group and user

schema.<span class="apidocCodeKeywordSpan">automigrate</span>(); // required only for mysql and postgres NOTE: it will drop User
 and Post tables

// work with models:
var user = new User;
user.save(function (err) {
    var post = user.posts.build({title: &#x27;Hello world&#x27;});
    post.save(console.log);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.command" id="apidoc.element.jugglingdb.BaseSQL.prototype.command">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>command
        <span class="apidocSignatureSpan">(sql, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">command = function (sql, callback) {
    return this.query(sql, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.count" id="apidoc.element.jugglingdb.BaseSQL.prototype.count">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>count
        <span class="apidocSignatureSpan">(model, callback, where)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(model, callback, where) {
    var self = this;
    var props = this._models[model].properties;

    this.queryOne(&#x27;SELECT count(*) as cnt FROM &#x27; +
        this.tableEscaped(model) + &#x27; &#x27; + buildWhere(where), function (err, res) {
        if (err) return callback(err);
        callback(err, res &#x26;&#x26; res.cnt);
    });

    function buildWhere(conds) {
        var cs = [];
        Object.keys(conds || {}).forEach(function (key) {
            var keyEscaped = self.escapeName(key);
            if (conds[key] === null) {
                cs.push(keyEscaped + &#x27; IS NULL&#x27;);
            } else {
                cs.push(keyEscaped + &#x27; = &#x27; + self.toDatabase(props[key], conds[key]));
            }
        });
        return cs.length ? &#x27; WHERE &#x27; + cs.join(&#x27; AND &#x27;) : &#x27;&#x27;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// same as new Post({userId: user.id});
user.posts.build
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.find(1, cb)
// count instances
User.<span class="apidocCodeKeywordSpan">count</span>([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
Post.update({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.createTable" id="apidoc.element.jugglingdb.BaseSQL.prototype.createTable">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>createTable
        <span class="apidocSignatureSpan">(model, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTable = function (model, cb) {
    this.command(&#x27;CREATE TABLE &#x27; + this.tableEscaped(model) +
        &#x27; (\n  &#x27; + this.propertiesSQL(model) + &#x27;\n)&#x27;, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.define" id="apidoc.element.jugglingdb.BaseSQL.prototype.define">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>define
        <span class="apidocSignatureSpan">(descr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (descr) {
    if (!descr.settings) descr.settings = {};
    this._models[descr.model.modelName] = descr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

```javascript
var Schema = require(&#x27;jugglingdb&#x27;).Schema;
var schema = new Schema(&#x27;redis&#x27;, {port: 6379}); //port number depends on your configuration
// define models
var Post = schema.<span class="apidocCodeKeywordSpan">define</span>(&#x27;Post&#x27;, {
    title:     { type: String, length: 255 },
    content:   { type: Schema.Text },
    date:      { type: Date,    default: function () { return new Date;} },
    timestamp: { type: Number,  default: Date.now },
    published: { type: Boolean, default: false, index: true }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.defineProperty" id="apidoc.element.jugglingdb.BaseSQL.prototype.defineProperty">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>defineProperty
        <span class="apidocSignatureSpan">(model, prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (model, prop, params) {
    this._models[model].properties[prop] = params;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var list = this;
if (!(list instanceof List)) {
    return new List(data);
}

if (data &#x26;&#x26; data instanceof List) data = data.items;

Object.<span class="apidocCodeKeywordSpan">defineProperty</span>(list, &#x27;parent&#x27;, {
    writable: false,
    enumerable: false,
    configurable: false,
    value: parent
});

Object.defineProperty(list, &#x27;nextid&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.destroy" id="apidoc.element.jugglingdb.BaseSQL.prototype.destroy">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>destroy
        <span class="apidocSignatureSpan">(model, id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy(model, id, callback) {
    var sql = &#x27;DELETE FROM &#x27; +
        this.tableEscaped(model) + &#x27; WHERE &#x27; + this.escapeName(&#x27;id&#x27;) + &#x27; = &#x27; + this.escapeId(id);

    this.command(sql, function (err) {
        callback(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.find(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.<span class="apidocCodeKeywordSpan">destroy</span>(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
Post.update({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
Post.update([{ where:{id:&#x27;1&#x27;}, update:{ published:false }},{ where:{id:&#x27;2&#x27;}, update:{ published:true }}], cb
);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.destroyAll" id="apidoc.element.jugglingdb.BaseSQL.prototype.destroyAll">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>destroyAll
        <span class="apidocSignatureSpan">(model, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(model, callback) {
    this.command(&#x27;DELETE FROM &#x27; + this.tableEscaped(model), function (err) {
        if (err) {
            return callback(err, []);
        }
        callback(err);
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// find instance by id
User.find(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.<span class="apidocCodeKeywordSpan">destroyAll</span>(cb);
// update a post (currently only on the mysql adapter)
Post.update({ where:{id:&#x27;1&#x27;}, update:{ published:false }}, cb);
// update bulk posts (currently only on the mysql adapter)
Post.update([{ where:{id:&#x27;1&#x27;}, update:{ published:false }},{ where:{id:&#x27;2&#x27;}, update:{ published:true }}], cb
);
```

SEE [model(3)](http://jugglingdb.co/model.3.html) for more information about
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.disconnect" id="apidoc.element.jugglingdb.BaseSQL.prototype.disconnect">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnect() {
    this.client.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Close database connection
 */
Schema.prototype.disconnect = function disconnect(cb) {
    if (typeof this.adapter.disconnect === &#x27;function&#x27;) {
        this.connected = false;
        this.adapter.<span class="apidocCodeKeywordSpan">disconnect</span>(cb);
        this.emit(&#x27;disconnected&#x27;);
    } else if (cb) {
        cb();
    }
};

Schema.prototype.copyModel = function copyModel(Master) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.dropTable" id="apidoc.element.jugglingdb.BaseSQL.prototype.dropTable">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>dropTable
        <span class="apidocSignatureSpan">(model, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dropTable = function (model, cb) {
    this.command(&#x27;DROP TABLE IF EXISTS &#x27; + this.tableEscaped(model), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.escapeId" id="apidoc.element.jugglingdb.BaseSQL.prototype.escapeId">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>escapeId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeId = function (id) {
    if (this.schema.settings.slave) {
        if (null === id) {
            return &#x27;NULL&#x27;;
        }
        return &#x27;&#x22;&#x27; + (&#x27;undefined&#x27; === typeof id ? &#x27;&#x27; : id.toString().replace(/[&#x22;\n]/g, &#x27;&#x27;)) + &#x27;&#x22;&#x27;;
    } else {
        var idNumber = Number(id);
        if (isNaN(idNumber)) {
            throw new Error(&#x27;id is not a number&#x27;);
        }
        return idNumber;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.escapeName" id="apidoc.element.jugglingdb.BaseSQL.prototype.escapeName">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>escapeName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeName = function (name) {
    throw new Error(&#x27;escapeName method should be declared in adapter&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.exists" id="apidoc.element.jugglingdb.BaseSQL.prototype.exists">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>exists
        <span class="apidocSignatureSpan">(model, id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (model, id, callback) {
    var sql = &#x27;SELECT 1 FROM &#x27; +
        this.tableEscaped(model) + &#x27; WHERE &#x27; + this.escapeName(&#x27;id&#x27;) + &#x27; = &#x27; + this.escapeId(id) + &#x27; LIMIT 1&#x27;;

    this.query(sql, function (err, data) {
        if (err) return callback(err);
        callback(null, data.length === 1);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.find" id="apidoc.element.jugglingdb.BaseSQL.prototype.find">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>find
        <span class="apidocSignatureSpan">(model, id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(model, id, callback) {
    var idNumber = this.escapeId(id);
    var sql = &#x27;SELECT * FROM &#x27; +
        this.tableEscaped(model) + &#x27; WHERE &#x27; + this.escapeName(&#x27;id&#x27;) + &#x27; = &#x27; + idNumber + &#x27; LIMIT 1&#x27;;

    this.query(sql, function (err, data) {
        if (data &#x26;&#x26; data.length === 1) {
            data[0].id = id;
        } else {
            data = [null];
        }
        callback(err, this.fromDatabase(model, data[0]));
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// get one latest post
Post.findOne({where: {published: true}, order: &#x27;date DESC&#x27;}, cb);
// same as new Post({userId: user.id});
user.posts.build
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.<span class="apidocCodeKeywordSpan">find</span>(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.query" id="apidoc.element.jugglingdb.BaseSQL.prototype.query">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>query
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function () {
    throw new Error(&#x27;query method should be declared in adapter&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.queryOne" id="apidoc.element.jugglingdb.BaseSQL.prototype.queryOne">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>queryOne
        <span class="apidocSignatureSpan">(sql, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queryOne = function (sql, callback) {
    return this.query(sql, function (err, data) {
        if (err) return callback(err);
        callback(err, data[0]);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.save" id="apidoc.element.jugglingdb.BaseSQL.prototype.save">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>save
        <span class="apidocSignatureSpan">(model, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function (model, data, callback) {
    var sql = &#x27;UPDATE &#x27; + this.tableEscaped(model) + &#x27; SET &#x27; + this.toFields(model, data) + &#x27; WHERE &#x27; + this.escapeName(&#x27;id&#x27;) + &#x27; = &#x27; +
this.escapeId(data.id);

    this.query(sql, function (err) {
        callback(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// user.groups.add(group, callback) - connect existing group with user
// user.groups.remove(group, callback) - remove connection between group and user

schema.automigrate(); // required only for mysql and postgres NOTE: it will drop User and Post tables

// work with models:
var user = new User;
user.<span class="apidocCodeKeywordSpan">save</span>(function (err) {
    var post = user.posts.build({title: &#x27;Hello world&#x27;});
    post.save(console.log);
});

// or just call it as function (with the same result):
var user = User();
user.save(...);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.table" id="apidoc.element.jugglingdb.BaseSQL.prototype.table">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>table
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">table = function (model) {
    return this._models[model].model.tableName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.tableEscaped" id="apidoc.element.jugglingdb.BaseSQL.prototype.tableEscaped">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>tableEscaped
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableEscaped = function (model) {
    return this.escapeName(this.table(model));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.BaseSQL.prototype.updateAttributes" id="apidoc.element.jugglingdb.BaseSQL.prototype.updateAttributes">
        function <span class="apidocSignatureSpan">jugglingdb.BaseSQL.prototype.</span>updateAttributes
        <span class="apidocSignatureSpan">(model, id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAttrs(model, id, data, cb) {
    data.id = id;
    this.save(model, data, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.Schema" id="apidoc.module.jugglingdb.Schema">module jugglingdb.Schema</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.Schema" id="apidoc.element.jugglingdb.Schema.Schema">
        function <span class="apidocSignatureSpan">jugglingdb.</span>Schema
        <span class="apidocSignatureSpan">(name, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(name, settings) {
    var schema = this;
    // just save everything we get
    this.name = name;
    this.settings = settings || {};

    // Disconnected by default
    this.connected = false;
    this.connecting = false;

    // create blank models pool
    this.models = {};
    this.definitions = {};

    if (this.settings.log) {
        this.on(&#x27;log&#x27;, function(str, duration) {
            console.log(str);
        });
    }

    // and initialize schema using adapter
    // this is only one initialization entry point of adapter
    // this module should define `adapter` member of `this` (schema)
    var adapter;
    if (typeof name === &#x27;object&#x27;) {
        adapter = name;
        this.name = adapter.name;
    } else if (name.match(/^\//)) {
        // try absolute path
        adapter = require(name);
    } else if (existsSync(__dirname + &#x27;/adapters/&#x27; + name + &#x27;.js&#x27;)) {
        // try built-in adapter
        adapter = require(&#x27;./adapters/&#x27; + name);
    } else {
        // try foreign adapter
        try {
            adapter = require(&#x27;jugglingdb-&#x27; + name);
        } catch (e) {
            return console.log(&#x27;\nWARNING: JugglingDB adapter &#x22;&#x27; + name + &#x27;&#x22; is not installed,\nso your models would not work, to
 fix run:\n\n    npm install jugglingdb-&#x27; + name, &#x27;\n&#x27;);
        }
    }

    this.connecting = true;
    adapter.initialize(this, function () {

        this.adapter.log = function (query, start) {
            schema.log(query, start);
        };

        this.adapter.logger = function (query) {
            var t1 = Date.now();
            var log = this.log;
            return function (q) {
                log(q || query, t1);
            };
        };

        this.connecting = false;
        this.connected = true;
        this.emit(&#x27;connected&#x27;);

    }.bind(this));

    // we have an adaper now?
    if (!this.adapter) {
        this.emit(&#x27;disconnected&#x27;);
        throw new Error(&#x27;Adapter &#x22;&#x27; + name + &#x27;&#x22; is not defined correctly: it should define `adapter` member of schema synchronously
&#x27;);
    }

    schema.connect = function(cb) {
        var schema = this;
        schema.connecting = true;
        return new when.Promise(function(resolve, reject) {
            if (!schema.adapter.connect) {
                return process.nextTick(function() {
                    schema.connecting = false;
                    if (cb) {
                        cb(null, schema);
                    }
                    return resolve(schema);
                });
            }
            schema.adapter.connect(function(err) {
                if (err) {
                    schema.connected = false;
                    schema.connecting = false;
                    reject(err);
                    if (cb) {
                        cb(err);
                    }
                } else {
                    schema.connected = true;
                    schema.connecting = false;
                    schema.emit(&#x27;connected&#x27;);
                    resolve(schema);
                    if (cb) {
                        cb(null, schema);
                    }
                }
            });
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.JSON" id="apidoc.element.jugglingdb.Schema.JSON">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>JSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSON() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.Text" id="apidoc.element.jugglingdb.Schema.Text">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>Text
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(s) { return s; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.registerType" id="apidoc.element.jugglingdb.Schema.registerType">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>registerType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerType = function (type) {
    this.types[type.name] = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Schema.JSON = function JSON() {};

Schema.types = {};
Schema.registerType = function (type) {
   this.types[type.name] = type;
};

Schema.<span class="apidocCodeKeywordSpan">registerType</span>(Schema.Text);
Schema.registerType(Schema.JSON);


/**
* Schema - adapter-specific classes factory.
*
* All classes in single schema shares same adapter type and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.super_" id="apidoc.element.jugglingdb.Schema.super_">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.Schema.prototype" id="apidoc.module.jugglingdb.Schema.prototype">module jugglingdb.Schema.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.automigrate" id="apidoc.element.jugglingdb.Schema.prototype.automigrate">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>automigrate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">automigrate = function (cb) {
    this.freeze();
    if (this.adapter.automigrate) {
        this.adapter.automigrate(cb);
    } else if (cb) {
        cb();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

User.hasAndBelongsToMany(&#x27;groups&#x27;);
// user.groups(callback) - get groups of user
// user.groups.create(data, callback) - create new group and connect with user
// user.groups.add(group, callback) - connect existing group with user
// user.groups.remove(group, callback) - remove connection between group and user

schema.<span class="apidocCodeKeywordSpan">automigrate</span>(); // required only for mysql and postgres NOTE: it will drop User
 and Post tables

// work with models:
var user = new User;
user.save(function (err) {
    var post = user.posts.build({title: &#x27;Hello world&#x27;});
    post.save(console.log);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.autoupdate" id="apidoc.element.jugglingdb.Schema.prototype.autoupdate">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>autoupdate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoupdate = function (cb) {
    this.freeze();
    if (this.adapter.autoupdate) {
        this.adapter.autoupdate(cb);
    } else if (cb) {
        cb();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    compound.root + &#x27;/db/schema&#x27;,
    compound.app.get(&#x27;database&#x27;),
    compound
);
if (compound.app.enabled(&#x27;autoupdate&#x27;)) {
    compound.on(&#x27;ready&#x27;, function() {
        compound.orm.schema.forEach(function(s) {
            s.<span class="apidocCodeKeywordSpan">autoupdate</span>();
            if (s.backyard) {
                s.backyard.autoupdate();
                s.backyard.log = s.log;
            }
        });
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.copyModel" id="apidoc.element.jugglingdb.Schema.prototype.copyModel">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>copyModel
        <span class="apidocSignatureSpan">(Master)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyModel(Master) {
    var schema = this;
    var className = Master.modelName;
    var md = Master.schema.definitions[className];
    var Slave = function SlaveModel() {
        Master.apply(this, [].slice.call(arguments));
        this.schema = schema;
    };

    util.inherits(Slave, Master);

    Slave.__proto__ = Master;

    hiddenProperty(Slave, &#x27;schema&#x27;, schema);
    hiddenProperty(Slave, &#x27;modelName&#x27;, className);
    hiddenProperty(Slave, &#x27;tableName&#x27;, Master.tableName);
    hiddenProperty(Slave, &#x27;relations&#x27;, Master.relations);

    if (!(className in schema.models)) {

        // store class in model pool
        schema.models[className] = Slave;
        schema.definitions[className] = {
            properties: md.properties,
            settings: md.settings
        };

        if (!schema.isTransaction) {
            schema.adapter.define({
                model:      Slave,
                properties: md.properties,
                settings:   md.settings
            });
        }

    }

    return Slave;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.define" id="apidoc.element.jugglingdb.Schema.prototype.define">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>define
        <span class="apidocSignatureSpan">(className, properties, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineClass(className, properties, settings) {
    var schema = this;
    var args = slice.call(arguments);

    if (!className) {
        throw new Error(&#x27;Class name required&#x27;);
    }
    if (args.length == 1) {
        properties = {};
        args.push(properties);
    }
    if (args.length == 2) {
        settings = {};
        args.push(settings);
    }

    settings = settings || {};

    if (&#x27;function&#x27; === typeof properties) {
        var props = {};
        properties({
            property: function(name, type, settings) {
                settings = settings || {};
                settings.type = type;
                props[name] = settings;
            },
            set: function(key, val) {
                settings[key] = val;
            }
        });
        properties = props;
    }

    properties = properties || {};

    // every class can receive hash of data as optional param
    var NewClass = function ModelConstructor(data, schema) {
        if (!(this instanceof ModelConstructor)) {
            return new ModelConstructor(data);
        }
        AbstractClass.call(this, data);
        hiddenProperty(this, &#x27;schema&#x27;, schema || this.constructor.schema);
    };

    hiddenProperty(NewClass, &#x27;schema&#x27;, schema);
    hiddenProperty(NewClass, &#x27;settings&#x27;, settings);
    hiddenProperty(NewClass, &#x27;properties&#x27;, properties);
    hiddenProperty(NewClass, &#x27;modelName&#x27;, className);
    hiddenProperty(NewClass, &#x27;tableName&#x27;, settings.table || className);
    hiddenProperty(NewClass, &#x27;relations&#x27;, {});

    // inherit AbstractClass methods
    for (var i in AbstractClass) {
        NewClass[i] = AbstractClass[i];
    }
    for (var j in AbstractClass.prototype) {
        NewClass.prototype[j] = AbstractClass.prototype[j];
    }

    NewClass.getter = {};
    NewClass.setter = {};

    standartize(properties, settings);

    // store class in model pool
    this.models[className] = NewClass;
    this.definitions[className] = {
        properties: properties,
        settings: settings
    };

    // pass control to adapter
    this.adapter.define({
        model:      NewClass,
        properties: properties,
        settings:   settings
    });

    NewClass.prototype.__defineGetter__(&#x27;id&#x27;, function () {
        return this.__data.id;
    });

    properties.id = properties.id || { type: schema.settings.slave ? String : Number };

    NewClass.forEachProperty = function (cb) {
        Object.keys(properties).forEach(cb);
    };

    NewClass.registerProperty = function (attr) {
        var DataType = properties[attr].type;
        if (DataType instanceof Array) {
            DataType = List;
        } else if (DataType.name === &#x27;Date&#x27;) {
            var OrigDate = Date;
            DataType = function Date(arg) {
                return new OrigDate(arg);
            };
        } else if (DataType.name === &#x27;JSON&#x27; || DataType === JSON) {
            DataType = function JSON(s) {
                return s;
            };
        } else if (DataType.name === &#x27;Text&#x27; || DataType === Schema.Text) {
            DataType = function Text(s) {
                return s;
            };
        }

        Object.defineProperty(NewClass.prototype, attr, {
            get: function () {
                if (NewClass.getter[attr]) {
                    return NewClass.getter[attr].call(this);
                } else {
                    return this.__data[attr];
                }
            },
            set: function (value) {
                if (NewClass.setter[attr]) {
                    NewClass.setter[attr].call(this, value);
                } else {
                    if (value === null || value === undefined || typeof DataType === &#x27;object&#x27;) {
                        this.__data[attr] = value;
                    } else if (DataType === Boolean) {
                        this.__data[attr] = value === &#x27;false&#x27; ? false : !!value;
                    } else {
                        this.__data[attr] = DataType(value);
                    }
                }
            },
            configurable: true,
            enumera ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

```javascript
var Schema = require(&#x27;jugglingdb&#x27;).Schema;
var schema = new Schema(&#x27;redis&#x27;, {port: 6379}); //port number depends on your configuration
// define models
var Post = schema.<span class="apidocCodeKeywordSpan">define</span>(&#x27;Post&#x27;, {
    title:     { type: String, length: 255 },
    content:   { type: Schema.Text },
    date:      { type: Date,    default: function () { return new Date;} },
    timestamp: { type: Number,  default: Date.now },
    published: { type: Boolean, default: false, index: true }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.defineForeignKey" id="apidoc.element.jugglingdb.Schema.prototype.defineForeignKey">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>defineForeignKey
        <span class="apidocSignatureSpan">(className, key, foreignClassName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineForeignKey(className, key, foreignClassName) {
    // quit if key already defined
    if (this.definitions[className].properties[key]) return;

    if (this.adapter.defineForeignKey) {
        var cb = function (err, keyType) {
            if (err) throw err;
            this.definitions[className].properties[key] = {type: keyType};
        }.bind(this);
        switch (this.adapter.defineForeignKey.length) {
            case 4:
                this.adapter.defineForeignKey(className, key, foreignClassName, cb);
            break;
            default:
            case 3:
                this.adapter.defineForeignKey(className, key, cb);
            break;
        }
    } else {
        this.definitions[className].properties[key] = {type: Number};
    }
    this.models[className].registerProperty(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        filter.include = filter.collect;
    }
    return filter;
}, scopeMethods);

if (!params.through) {
    // obviously, anotherClass should have attribute called `fk`
    anotherClass.schema.<span class="apidocCodeKeywordSpan">defineForeignKey</span>(anotherClass.modelName, fk, this.modelName);
}

function find(id, cb) {
    anotherClass.find(id, function (err, inst) {
        if (err) return cb(err);
        if (!inst) return cb(new Error(&#x27;Not found&#x27;));
        if (inst[fk] &#x26;&#x26; inst[fk].toString() == this.id.toString()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.defineProperty" id="apidoc.element.jugglingdb.Schema.prototype.defineProperty">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>defineProperty
        <span class="apidocSignatureSpan">(model, prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (model, prop, params) {
    this.definitions[model].properties[prop] = params;
    this.models[model].registerProperty(prop);
    if (this.adapter.defineProperty) {
        this.adapter.defineProperty(model, prop, params);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var list = this;
if (!(list instanceof List)) {
    return new List(data);
}

if (data &#x26;&#x26; data instanceof List) data = data.items;

Object.<span class="apidocCodeKeywordSpan">defineProperty</span>(list, &#x27;parent&#x27;, {
    writable: false,
    enumerable: false,
    configurable: false,
    value: parent
});

Object.defineProperty(list, &#x27;nextid&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.disconnect" id="apidoc.element.jugglingdb.Schema.prototype.disconnect">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnect(cb) {
    if (typeof this.adapter.disconnect === &#x27;function&#x27;) {
        this.connected = false;
        this.adapter.disconnect(cb);
        this.emit(&#x27;disconnected&#x27;);
    } else if (cb) {
        cb();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Close database connection
 */
Schema.prototype.disconnect = function disconnect(cb) {
    if (typeof this.adapter.disconnect === &#x27;function&#x27;) {
        this.connected = false;
        this.adapter.<span class="apidocCodeKeywordSpan">disconnect</span>(cb);
        this.emit(&#x27;disconnected&#x27;);
    } else if (cb) {
        cb();
    }
};

Schema.prototype.copyModel = function copyModel(Master) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.extendModel" id="apidoc.element.jugglingdb.Schema.prototype.extendModel">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>extendModel
        <span class="apidocSignatureSpan">(model, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendModel = function (model, props) {
    var t = this;
    standartize(props, {});
    Object.keys(props).forEach(function (propName) {
        var definition = props[propName];
        t.defineProperty(model, propName, definition);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *     // amend the content model with competition attributes
 *     db.defineProperty(&#x27;Content&#x27;, &#x27;competitionType&#x27;, { type: String });
 *     db.defineProperty(&#x27;Content&#x27;, &#x27;expiryDate&#x27;, { type: Date, index: true });
 *     db.defineProperty(&#x27;Content&#x27;, &#x27;isExpired&#x27;, { type: Boolean, index: true });
 *
 *     // schema.extend allows to
 *     // extend the content model with competition attributes
 *     db.<span class="apidocCodeKeywordSpan">extendModel</span>(&#x27;Content&#x27;, {
 *       competitionType: String,
 *       expiryDate: { type: Date, index: true },
 *       isExpired: { type: Boolean, index: true }
 *     });
 */
Schema.prototype.extendModel = function (model, props) {
var t = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.freeze" id="apidoc.element.jugglingdb.Schema.prototype.freeze">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>freeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function freeze() {
    if (this.adapter.freezeSchema) {
        this.adapter.freezeSchema();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// autoupdate if set app.enable(&#x27;autoupdate&#x27;)  or freeze schemas by default
railway.orm._schemas.forEach(function (schema) {
    if(app.enabled(&#x27;autoupdate&#x27;)){
        schema.autoupdate();
    } else {
        schema.<span class="apidocCodeKeywordSpan">freeze</span>();
    }
});
}

function log(str, startTime) {
var $ = railway.utils.stylize.$;
var m = Date.now() - startTime;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.isActual" id="apidoc.element.jugglingdb.Schema.prototype.isActual">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>isActual
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isActual = function (cb) {
    this.freeze();
    if (this.adapter.isActual) {
        this.adapter.isActual(cb);
    } else if (cb) {
        cb(null, true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Check whether migrations needed
* This method make sense only for sql adapters.
*/
Schema.prototype.isActual = function (cb) {
   this.freeze();
   if (this.adapter.isActual) {
       this.adapter.<span class="apidocCodeKeywordSpan">isActual</span>(cb);
   } else if (cb) {
       cb(null, true);
   }
};

/**
* Log benchmarked message. Do not redefine this method, if you need to grab
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.log" id="apidoc.element.jugglingdb.Schema.prototype.log">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>log
        <span class="apidocSignatureSpan">(sql, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (sql, t) {
    this.emit(&#x27;log&#x27;, sql, t);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.loadSchema = function(filename, settings, compound) {
var schema = [];
var definitions = require(filename);
Object.keys(definitions).forEach(function(k) {
    var conf = settings[k];
    if (!conf) {
        console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;No config found for &#x27; + k + &#x27; schema, using in-memory
 schema&#x27;);
        conf = {driver: &#x27;memory&#x27;};
    }
    schema[k] = new Schema(conf.driver, conf);
    schema[k].on(&#x27;define&#x27;, function(m, name, prop, sett) {
        compound.models[name] = m;
        if (conf.backyard) {
            schema[k].backyard.define(name, prop, sett);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.tableName" id="apidoc.element.jugglingdb.Schema.prototype.tableName">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>tableName
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableName = function (modelName) {
    return this.models[modelName].model.tableName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.prototype.transaction" id="apidoc.element.jugglingdb.Schema.prototype.transaction">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.prototype.</span>transaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transaction = function () {
    var schema = this;
    var transaction = new EventEmitter();
    transaction.isTransaction = true;
    transaction.origin = schema;
    transaction.name = schema.name;
    transaction.settings = schema.settings;
    transaction.connected = false;
    transaction.connecting = false;
    transaction.adapter = schema.adapter.transaction();

    // create blank models pool
    transaction.models = {};
    transaction.definitions = {};

    for (var i in schema.models) {
        schema.copyModel.call(transaction, schema.models[i]);
    }

    transaction.connect = schema.connect;

    transaction.exec = function(cb) {
        transaction.adapter.exec(cb);
    };

    return transaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var transaction = new EventEmitter();
transaction.isTransaction = true;
transaction.origin = schema;
transaction.name = schema.name;
transaction.settings = schema.settings;
transaction.connected = false;
transaction.connecting = false;
transaction.adapter = schema.adapter.<span class="apidocCodeKeywordSpan">transaction</span>();

// create blank models pool
transaction.models = {};
transaction.definitions = {};

for (var i in schema.models) {
    schema.copyModel.call(transaction, schema.models[i]);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.Schema.types" id="apidoc.module.jugglingdb.Schema.types">module jugglingdb.Schema.types</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.types.JSON" id="apidoc.element.jugglingdb.Schema.types.JSON">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.types.</span>JSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSON() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.Schema.types.Text" id="apidoc.element.jugglingdb.Schema.types.Text">
        function <span class="apidocSignatureSpan">jugglingdb.Schema.types.</span>Text
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(s) { return s; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.jutil" id="apidoc.module.jugglingdb.jutil">module jugglingdb.jutil</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.jutil.inherits" id="apidoc.element.jugglingdb.jutil.inherits">
        function <span class="apidocSignatureSpan">jugglingdb.jutil.</span>inherits
        <span class="apidocSignatureSpan">(newClass, baseClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (newClass, baseClass) {
    Object.keys(baseClass).forEach(function (classMethod) {
        newClass[classMethod] = baseClass[classMethod];
    });
    Object.keys(baseClass.prototype).forEach(function (instanceMethod) {
        newClass.prototype[instanceMethod] = baseClass.prototype[instanceMethod];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                   }
               }
           });
       });
   };
}

util.<span class="apidocCodeKeywordSpan">inherits</span>(Schema, EventEmitter);

/**
* Define class
*
* @param {String} className
* @param {Object} properties - hash of class properties in format
*   `{property: Type, property2: Type2, ...}`
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.list" id="apidoc.module.jugglingdb.list">module jugglingdb.list</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.list.list" id="apidoc.element.jugglingdb.list.list">
        function <span class="apidocSignatureSpan">jugglingdb.</span>list
        <span class="apidocSignatureSpan">(data, type, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(data, type, parent) {
    var list = this;
    if (!(list instanceof List)) {
        return new List(data);
    }

    if (data &#x26;&#x26; data instanceof List) data = data.items;

    Object.defineProperty(list, &#x27;parent&#x27;, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: parent
    });

    Object.defineProperty(list, &#x27;nextid&#x27;, {
        writable: true,
        enumerable: false,
        value: 1
    });

    var Item = ListItem;
    if (typeof type === &#x27;object&#x27; &#x26;&#x26; type.constructor.name === &#x27;Array&#x27;) {
        Item = type[0] || ListItem;
    }

    data = list.items = data || [];
    Object.defineProperty(list, &#x27;ItemType&#x27;, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: Item
    });

    if (&#x27;string&#x27; === typeof data) {
        try {
            list.items = data = JSON.parse(data);
        } catch(e) {
            list.items = data = [];
        }
    }

    data.forEach(function(item, i) {
        data[i] = new Item(item, list);
        Object.defineProperty(list, data[i].id, {
            writable: true,
            enumerable: false,
            configurable: true,
            value: data[i]
        });
        if (list.nextid &#x3c;= data[i].id) {
            list.nextid = data[i].id + 1;
        }
    });

    Object.defineProperty(list, &#x27;length&#x27;, {
        enumerable: false,
        configurable: true,
        get: function() {
            return list.items.length;
        }
    });

    return list;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.list.prototype" id="apidoc.module.jugglingdb.list.prototype">module jugglingdb.list.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.autoincrement" id="apidoc.element.jugglingdb.list.prototype.autoincrement">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>autoincrement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoincrement = function () {
    return this.nextid++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Object.defineProperty(this, &#x27;parent&#x27;, {
    writable: false,
    enumerable: false,
    configurable: true,
    value: parent
});
if (!this.id) {
    this.id = parent.<span class="apidocCodeKeywordSpan">autoincrement</span>();
}
if (parent.ItemType) {
    this.__proto__ = parent.ItemType.prototype;
    if (parent.ItemType !== ListItem) {
        parent.ItemType.apply(this);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.concat" id="apidoc.element.jugglingdb.list.prototype.concat">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.every" id="apidoc.element.jugglingdb.list.prototype.every">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>every
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.filter" id="apidoc.element.jugglingdb.list.prototype.filter">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>filter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var req = {
    &#x27;where&#x27;: {}
};

if (!keyVals[relation.keyFrom]) {
    objsByKeys[relation.keyFrom] = {};
    objs.<span class="apidocCodeKeywordSpan">filter</span>(Boolean).forEach(function (obj) {
        if (!objsByKeys[relation.keyFrom][obj[relation.keyFrom]]) {
            objsByKeys[relation.keyFrom][obj[relation.keyFrom]] = [];
        }
        objsByKeys[relation.keyFrom][obj[relation.keyFrom]].push(obj);
    });
    keyVals[relation.keyFrom] = Object.keys(objsByKeys[relation.keyFrom]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.find" id="apidoc.element.jugglingdb.list.prototype.find">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>find
        <span class="apidocSignatureSpan">(pattern, field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (pattern, field) {
    if (!field) {
        field = &#x27;id&#x27;;
    }
    var res;
    this.items.forEach(function(o) {
        if (o[field] == pattern) res = o;
    });
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// get one latest post
Post.findOne({where: {published: true}, order: &#x27;date DESC&#x27;}, cb);
// same as new Post({userId: user.id});
user.posts.build
// save as Post.create({userId: user.id}, cb);
user.posts.create(cb)
// find instance by id
User.<span class="apidocCodeKeywordSpan">find</span>(1, cb)
// count instances
User.count([conditions, ]cb)
// destroy instance
user.destroy(cb);
// destroy all instances
User.destroyAll(cb);
// update a post (currently only on the mysql adapter)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.forEach" id="apidoc.element.jugglingdb.list.prototype.forEach">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>forEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.__defineGetter__(&#x27;BaseSQL&#x27;, function () {
return require(baseSQL);
});

exports.loadSchema = function(filename, settings, compound) {
var schema = [];
var definitions = require(filename);
Object.keys(definitions).<span class="apidocCodeKeywordSpan">forEach</span>(function(k) {
    var conf = settings[k];
    if (!conf) {
        console.log(&#x27;No config found for &#x27; + k + &#x27; schema, using in-memory schema&#x27;);
        conf = {driver: &#x27;memory&#x27;};
    }
    schema[k] = new Schema(conf.driver, conf);
    schema[k].on(&#x27;define&#x27;, function(m, name, prop, sett) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.indexOf" id="apidoc.element.jugglingdb.list.prototype.indexOf">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>indexOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Inclusion validator
*/
function validateInclusion(attr, conf, err) {
   if (nullCheck.call(this, attr, conf, err)) return;

   if (!~conf.in.<span class="apidocCodeKeywordSpan">indexOf</span>(this[attr])) {
       err();
   }
}

/**
* Exclusion validator
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.inspect" id="apidoc.element.jugglingdb.list.prototype.inspect">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
    return util.inspect(this.items);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    return list;

}

List.prototype.inspect = function() {
    return util.<span class="apidocCodeKeywordSpan">inspect</span>(this.items);
};

var _;
try {
    var underscore = &#x27;underscore&#x27;;
    _ = require(underscore);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.join" id="apidoc.element.jugglingdb.list.prototype.join">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!config) {
        console.log(&#x27;No environment &#x27; + env + &#x27; found in config/database.{js|json|yml}&#x27;);
        throw new Error(&#x27;No environment &#x27; + env + &#x27; found in config/database.{js|json|yml}&#x27;);
    }

    // when driver name started with point - look for driver in app root (relative path)
    if (config.driver &#x26;&#x26; config.driver.match(/^\./)) {
        config.driver = path.<span class="apidocCodeKeywordSpan">join</span>(app.root, config.driver);
    }

    schema = new Schema(config &#x26;&#x26; config.driver || &#x27;memory&#x27;, config);
    schema.log = log;
    if (!schema.adapter) throw new Error(&#x27;Adapter is not defined&#x27;);

} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.lastIndexOf" id="apidoc.element.jugglingdb.list.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.map" id="apidoc.element.jugglingdb.list.prototype.map">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>map
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (cb) {
    if (typeof cb === &#x27;function&#x27;) {
        return this.items.map(cb);
    }
    if (typeof cb === &#x27;string&#x27;) {
        return this.items.map(function(el) {
            if (typeof el[cb] === &#x27;function&#x27;) {
                return el[cb]();
            }
            if (el.hasOwnProperty(cb)) {
                return el[cb];
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete this[id];
    this.items.splice(found, 1);
}
};

List.prototype.map = function(cb) {
if (typeof cb === &#x27;function&#x27;) {
    return this.items.<span class="apidocCodeKeywordSpan">map</span>(cb);
}
if (typeof cb === &#x27;string&#x27;) {
    return this.items.map(function(el) {
        if (typeof el[cb] === &#x27;function&#x27;) {
            return el[cb]();
        }
        if (el.hasOwnProperty(cb)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.pop" id="apidoc.element.jugglingdb.list.prototype.pop">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        enumerable: false,
        value: []
    });
}
args = [].slice.call(args);
var conf;
if (typeof args[args.length - 1] === &#x27;object&#x27;) {
    conf = args.<span class="apidocCodeKeywordSpan">pop</span>();
} else {
    conf = {};
}
if (validation === &#x27;custom&#x27; &#x26;&#x26; typeof args[args.length - 1] === &#x27;function&#x27;) {
    conf.customValidator = args.pop();
}
conf.validation = validation;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.push" id="apidoc.element.jugglingdb.list.prototype.push">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>push
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (obj) {
    var item = new ListItem(obj, this);
    this.items.push(item);
    return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
schema[k].on(&#x27;define&#x27;, function(m, name, prop, sett) {
    compound.models[name] = m;
    if (conf.backyard) {
        schema[k].backyard.define(name, prop, sett);
    }
});
schema[k].name = k;
schema.<span class="apidocCodeKeywordSpan">push</span>(schema[k]);
if (conf.backyard) {
    schema[k].backyard = new Schema(conf.backyard.driver, conf.backyard);
}
if (&#x27;function&#x27; === typeof definitions[k]) {
    define(schema[k], definitions[k]);
    if (conf.backyard) {
        define(schema[k].backyard, definitions[k]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.remove" id="apidoc.element.jugglingdb.list.prototype.remove">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>remove
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (obj) {
    var id = obj.id ? obj.id : obj;
    var found = false;
    this.items.forEach(function(o, i) {
        if (id &#x26;&#x26; o.id == id) {
            found = i;
            if (o.id !== id) {
                console.log(&#x27;WARNING! Type of id not matched&#x27;);
            }
        }
    });
    if (found !== false) {
        delete this[id];
        this.items.splice(found, 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// post.author() -- sync getter when called without params
// post.author(user) -- setter when called with object

User.hasAndBelongsToMany(&#x27;groups&#x27;);
// user.groups(callback) - get groups of user
// user.groups.create(data, callback) - create new group and connect with user
// user.groups.add(group, callback) - connect existing group with user
// user.groups.<span class="apidocCodeKeywordSpan">remove</span>(group, callback) - remove connection between group and user

schema.automigrate(); // required only for mysql and postgres NOTE: it will drop User and Post tables

// work with models:
var user = new User;
user.save(function (err) {
var post = user.posts.build({title: &#x27;Hello world&#x27;});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.removeAt" id="apidoc.element.jugglingdb.list.prototype.removeAt">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>removeAt
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAt = function (index) {
    this.splice(index, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.reverse" id="apidoc.element.jugglingdb.list.prototype.reverse">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.shift" id="apidoc.element.jugglingdb.list.prototype.shift">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function destroyAll(cb) {
targetClass.all(this._scope, function (err, data) {
    if (err) {
        cb(err);
    } else {
        (function loopOfDestruction (data) {
            if(data.length &#x3e; 0) {
                data.<span class="apidocCodeKeywordSpan">shift</span>().destroy(function(err) {
                    if(err &#x26;&#x26; cb) cb(err);
                    loopOfDestruction(data);
                });
            } else {
                if(cb) cb();
            }
        }(data));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.slice" id="apidoc.element.jugglingdb.list.prototype.slice">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        } else if (done) {
            done.call(this);
        }
    }
};

function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.<span class="apidocCodeKeywordSpan">slice</span>(1);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.some" id="apidoc.element.jugglingdb.list.prototype.some">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>some
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.sort" id="apidoc.element.jugglingdb.list.prototype.sort">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.splice" id="apidoc.element.jugglingdb.list.prototype.splice">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>splice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.items.forEach(function(o) {
        if (o[field] == pattern) res = o;
    });
    return res;
};

List.prototype.removeAt = function(index) {
    this.<span class="apidocCodeKeywordSpan">splice</span>(index, 1);
};

List.prototype.toObject = function() {
    return this.items;
};

List.prototype.toJSON = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.toJSON" id="apidoc.element.jugglingdb.list.prototype.toJSON">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    return this.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.toObject" id="apidoc.element.jugglingdb.list.prototype.toObject">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function () {
    return this.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.toSource" id="apidoc.element.jugglingdb.list.prototype.toSource">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSource = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.toString" id="apidoc.element.jugglingdb.list.prototype.toString">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return JSON.stringify(this.items);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (existsSync(schemaFile + &#x27;coffee&#x27;)) {
    schemaFile += &#x27;coffee&#x27;;
} else {
    schemaFile = false;
}

if (schemaFile) {
    var code = fs.readFileSync(schemaFile).<span class="apidocCodeKeywordSpan">toString</span>();
    if (schemaFile.match(/\.coffee$/)) {
        code = require(&#x27;coffee-script&#x27;).compile(code);
    }
    /*jshint evil: true */
    var fn = new Function(&#x27;context&#x27;, &#x27;require&#x27;, &#x27;with(context){(function(){&#x27; + code + &#x27;})()}&#
x27;);
    fn(context, require);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jugglingdb.list.prototype.unshift" id="apidoc.element.jugglingdb.list.prototype.unshift">
        function <span class="apidocSignatureSpan">jugglingdb.list.prototype.</span>unshift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function () {
    return Array.prototype[method].apply(this.items, slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x27;lastIndexOf&#x27;,
        &#x27;range&#x27;
    ];

    _import.forEach(function(name) {
        List.prototype[name] = function() {
            var args = [].slice.call(arguments);
            args.<span class="apidocCodeKeywordSpan">unshift</span>(this.items);
            return _[name].apply(_, args);
        };
    });
}

// copy all array methods
[   &#x27;concat&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.schema" id="apidoc.module.jugglingdb.schema">module jugglingdb.schema</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.schema.Schema" id="apidoc.element.jugglingdb.schema.Schema">
        function <span class="apidocSignatureSpan">jugglingdb.schema.</span>Schema
        <span class="apidocSignatureSpan">(name, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(name, settings) {
    var schema = this;
    // just save everything we get
    this.name = name;
    this.settings = settings || {};

    // Disconnected by default
    this.connected = false;
    this.connecting = false;

    // create blank models pool
    this.models = {};
    this.definitions = {};

    if (this.settings.log) {
        this.on(&#x27;log&#x27;, function(str, duration) {
            console.log(str);
        });
    }

    // and initialize schema using adapter
    // this is only one initialization entry point of adapter
    // this module should define `adapter` member of `this` (schema)
    var adapter;
    if (typeof name === &#x27;object&#x27;) {
        adapter = name;
        this.name = adapter.name;
    } else if (name.match(/^\//)) {
        // try absolute path
        adapter = require(name);
    } else if (existsSync(__dirname + &#x27;/adapters/&#x27; + name + &#x27;.js&#x27;)) {
        // try built-in adapter
        adapter = require(&#x27;./adapters/&#x27; + name);
    } else {
        // try foreign adapter
        try {
            adapter = require(&#x27;jugglingdb-&#x27; + name);
        } catch (e) {
            return console.log(&#x27;\nWARNING: JugglingDB adapter &#x22;&#x27; + name + &#x27;&#x22; is not installed,\nso your models would not work, to
 fix run:\n\n    npm install jugglingdb-&#x27; + name, &#x27;\n&#x27;);
        }
    }

    this.connecting = true;
    adapter.initialize(this, function () {

        this.adapter.log = function (query, start) {
            schema.log(query, start);
        };

        this.adapter.logger = function (query) {
            var t1 = Date.now();
            var log = this.log;
            return function (q) {
                log(q || query, t1);
            };
        };

        this.connecting = false;
        this.connected = true;
        this.emit(&#x27;connected&#x27;);

    }.bind(this));

    // we have an adaper now?
    if (!this.adapter) {
        this.emit(&#x27;disconnected&#x27;);
        throw new Error(&#x27;Adapter &#x22;&#x27; + name + &#x27;&#x22; is not defined correctly: it should define `adapter` member of schema synchronously
&#x27;);
    }

    schema.connect = function(cb) {
        var schema = this;
        schema.connecting = true;
        return new when.Promise(function(resolve, reject) {
            if (!schema.adapter.connect) {
                return process.nextTick(function() {
                    schema.connecting = false;
                    if (cb) {
                        cb(null, schema);
                    }
                    return resolve(schema);
                });
            }
            schema.adapter.connect(function(err) {
                if (err) {
                    schema.connected = false;
                    schema.connecting = false;
                    reject(err);
                    if (cb) {
                        cb(err);
                    }
                } else {
                    schema.connected = true;
                    schema.connecting = false;
                    schema.emit(&#x27;connected&#x27;);
                    resolve(schema);
                    if (cb) {
                        cb(null, schema);
                    }
                }
            });
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.scope" id="apidoc.module.jugglingdb.scope">module jugglingdb.scope</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.scope.defineScope" id="apidoc.element.jugglingdb.scope.defineScope">
        function <span class="apidocSignatureSpan">jugglingdb.scope.</span>defineScope
        <span class="apidocSignatureSpan">(cls, targetClass, name, params, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineScope(cls, targetClass, name, params, methods) {

    // collect meta info about scope
    if (!cls._scopeMeta) {
        cls._scopeMeta = {};
    }

    // only makes sence to add scope in meta if base and target classes
    // are same
    if (cls === targetClass) {
        cls._scopeMeta[name] = params;
    } else {
        if (!targetClass._scopeMeta) {
            targetClass._scopeMeta = {};
        }
    }

    Object.defineProperty(cls, name, {
        enumerable: false,
        configurable: true,
        get: function () {
            var f = function caller(condOrRefresh, cb) {
                var actualCond = {};
                var actualRefresh = false;
                var saveOnCache = true;
                if (arguments.length === 1) {
                    cb = condOrRefresh;
                } else if (arguments.length === 2) {
                    if (typeof condOrRefresh === &#x27;boolean&#x27;) {
                        actualRefresh = condOrRefresh;
                    } else {
                        actualCond = condOrRefresh;
                        actualRefresh = true;
                        saveOnCache = false;
                    }
                } else {
                    throw new Error(&#x27;Method can be only called with one or two arguments&#x27;);
                }

                if (!this.__cachedRelations || (typeof this.__cachedRelations[name] == &#x27;undefined&#x27;) || actualRefresh) {
                    var self = this;
                    var params = mergeParams(actualCond, caller._scope);
                    return targetClass.all(params, function(err, data) {
                        if (!err &#x26;&#x26; saveOnCache) {
                            if (!self.__cachedRelations) {
                                self.__cachedRelations = {};
                            }
                            self.__cachedRelations[name] = data;
                        }
                        cb(err, data);
                    });
                } else {
                    cb(null, this.__cachedRelations[name]);
                }
            };
            f._scope = typeof params === &#x27;function&#x27; ? params.call(this) : params;
            f.build = build;
            f.create = create;
            f.destroyAll = destroyAll;
            for (var i in methods) {
                f[i] = methods[i].bind(this);
            }

            // define sub-scopes
            Object.keys(targetClass._scopeMeta).forEach(function (name) {
                Object.defineProperty(f, name, {
                    enumerable: false,
                    get: function () {
                        mergeParams(f._scope, targetClass._scopeMeta[name]);
                        return f;
                    }
                });
            }.bind(this));
            return f;
        }
    });

    // and it should have create/build methods with binded thisModelNameId param
    function build(data) {
        return new targetClass(mergeParams(this._scope, {where:data || {}}).where);
    }

    function create(data, cb) {
        if (typeof data === &#x27;function&#x27;) {
            cb = data;
            data = {};
        }
        this.build(data).save(cb);
    }

<span class="apidocCodeCommentSpan">    /*
        Callback
        - The callback will be called after all elements are destroyed
        - For every destroy call which results in an error
        - If fetching the Elements on which destroyAll is called results in an error
    */
</span>    function destroyAll(cb) {
        targetClass.all(this._scope, function (err, data) {
            if (err) {
                cb(err);
            } else {
                (function loopOfDestruction (data) {
                    if(data.length &#x3e; 0) {
                        data.shift().destroy(function(err) {
                            if(err &#x26;&#x26; cb) cb(err);
                            loopOfDestruction(data);
                        });
                    } else {
                        if(cb) cb();
                    }
                }(data));
            }
        });
    }

    function mergeParams(base, update) {
        if (updat ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.utils" id="apidoc.module.jugglingdb.utils">module jugglingdb.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.utils.safeRequire" id="apidoc.element.jugglingdb.utils.safeRequire">
        function <span class="apidocSignatureSpan">jugglingdb.utils.</span>safeRequire
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function safeRequire(module) {
    try {
        return require(module);
    } catch (e) {
        console.log(&#x27;Run &#x22;npm install jugglingdb &#x27; + module + &#x27;&#x22; command to use jugglingdb using &#x27; + module + &#x27; database engine&#x27;);
        process.exit(1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jugglingdb.validations" id="apidoc.module.jugglingdb.validations">module jugglingdb.validations</a></h1>


    <h2>
        <a href="#apidoc.element.jugglingdb.validations.ValidationError" id="apidoc.element.jugglingdb.validations.ValidationError">
        function <span class="apidocSignatureSpan">jugglingdb.validations.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
    if (!(this instanceof ValidationError)) return new ValidationError(obj);

    this.name = &#x27;ValidationError&#x27;;
    this.message = &#x27;Validation error&#x27;;
    this.statusCode = 400;
    this.codes = obj.errors &#x26;&#x26; obj.errors.__codes;
    this.context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;

    Error.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
